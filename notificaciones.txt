# PLAN DE IMPLEMENTACIÓN - NOTIFICACIONES NATIVAS CON KOTLIN
# =============================================================

## ÍNDICE
## ======
1. DATOS DEL WIZARD (De dónde provienen)
2. ARQUITECTURA DE ARCHIVOS
3. FASES DE IMPLEMENTACIÓN
4. ORDEN DE CREACIÓN DE ARCHIVOS
5. FLUJO DE DATOS COMPLETO


## 1. DATOS DEL WIZARD - ORIGEN Y UBICACIÓN
## ==========================================

### 1.1. Valores capturados en el Wizard (Redux)

**Ubicación en Redux:**
- Slice: `src/store/slices/settingsSlice.ts`
- State path: `state.settings.data`

**Valores disponibles:**

```typescript
interface UserSettings {
  // Paso 2: StepNameMotivation
  nickname: string                    // Ej: "María"
  motivational: string                // Ej: "Cada día una palabra nueva"

  // Paso 3: StepCategories
  categories: string[]                // Ej: ["technology", "business", "science"]

  // Paso 4: StepWeeklyTarget
  weekly_words_target: 10 | 30 | 40 | 50    // Ej: 30
  daily_words: number                 // CALCULADO: ceil(30/7) = 5

  // Paso 5: StepBurstsAndTimes
  bursts_per_day: 1 | 2 | 3          // Ej: 2
  active_windows: TimeWindowId[]      // Ej: ["morning", "evening"]
  window_times: {
    morning?: string                  // Ej: "08:00"
    afternoon?: string                // Ej: "14:00"
    evening?: string                  // Ej: "20:00"
  }
  words_per_burst: number             // CALCULADO: ceil(daily_words / bursts_per_day) = 3

  // Paso 6: StepStreakGoal (NO se usa en notificaciones)
  streak_goal_days: number            // Solo para gamificación

  // Control
  wizard_completed: boolean           // true cuando completa wizard
}
```

### 1.2. Cómo leer estos datos en React Native

```typescript
// En cualquier componente/hook
import { useSelector } from 'react-redux'
import { RootState } from '@/store/store'

const settings = useSelector((state: RootState) => state.settings.data)

// Usar los valores:
const nickname = settings.nickname              // "María"
const categories = settings.categories          // ["technology", "business"]
const activeWindows = settings.active_windows   // ["morning", "evening"]
const windowTimes = settings.window_times       // { morning: "08:00", evening: "20:00" }
const wordsPerBurst = settings.words_per_burst  // 3
```


## 2. ARQUITECTURA DE ARCHIVOS
## =============================

### 2.1. Archivos Android (Kotlin)

```
android/app/src/main/java/com/awesome/
├── notifications/
│   ├── NotificationModule.kt          # Bridge React Native -> Kotlin
│   ├── NotificationScheduler.kt       # Gestión de AlarmManager
│   ├── NotificationReceiver.kt        # Recibe alarmas y muestra notificaciones
│   ├── NotificationHelper.kt          # Crea las notificaciones visuales
│   ├── WordsDataStore.kt              # Almacena palabras en SharedPreferences
│   └── BootReceiver.kt                # Reprograma al reiniciar dispositivo
└── MainApplication.kt                  # Registrar módulo (MODIFICAR)

android/app/src/main/
└── AndroidManifest.xml                 # Permisos y receivers (MODIFICAR)

android/app/
└── build.gradle                        # Dependencias Gson (MODIFICAR)
```

### 2.2. Archivos React Native (TypeScript)

```
src/
├── services/
│   └── notificationService.ts         # Bridge tipado para Kotlin
└── hooks/
    └── useNotifications.ts            # Hook para programar notificaciones
```


## 3. FASES DE IMPLEMENTACIÓN
## ===========================

### FASE 1: Configuración base Android
### FASE 2: Módulos Kotlin nativos
### FASE 3: Bridge React Native
### FASE 4: Integración con Wizard
### FASE 5: Testing y validación


## 4. ORDEN DE CREACIÓN DE ARCHIVOS
## =================================

### FASE 1: CONFIGURACIÓN BASE ANDROID (3 archivos)

#### Archivo 1.1: android/app/src/main/AndroidManifest.xml
**QUÉ HACE:** Declara permisos y receivers
**AGREGAR DENTRO DE `<manifest>`:**

```xml
<!-- Permisos necesarios -->
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
<uses-permission android:name="android.permission.USE_EXACT_ALARM" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
```

**AGREGAR DENTRO DE `<application>`:**

```xml
<!-- Receiver para notificaciones programadas -->
<receiver
    android:name=".notifications.NotificationReceiver"
    android:enabled="true"
    android:exported="false">
    <intent-filter>
        <action android:name="com.vocabox.hermes.SHOW_NOTIFICATION" />
    </intent-filter>
</receiver>

<!-- Receiver para reinicio de dispositivo -->
<receiver
    android:name=".notifications.BootReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <action android:name="android.intent.action.QUICKBOOT_POWERON" />
    </intent-filter>
</receiver>
```

---

#### Archivo 1.2: android/app/build.gradle
**QUÉ HACE:** Agrega dependencia Gson para JSON
**AGREGAR EN `dependencies {}`:**

```gradle
// Gson para serialización JSON de palabras
implementation 'com.google.code.gson:gson:2.10.1'
```

---

#### Archivo 1.3: Crear carpeta notifications
**EJECUTAR EN TERMINAL:**

```bash
mkdir -p android/app/src/main/java/com/awesome/notifications
```

**NOTA:** Cambiar `com/awesome` por el package name de tu app


---

### FASE 2: MÓDULOS KOTLIN NATIVOS (6 archivos)

#### Archivo 2.1: WordsDataStore.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/WordsDataStore.kt`
**QUÉ HACE:** Almacena palabras y configuración en SharedPreferences
**DATOS QUE GUARDA:**
- Lista de palabras (word, meaning, category)
- Categorías seleccionadas
- Words per burst
- Nickname

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

data class WordData(
    val id: String,
    val word: String,
    val meaning: String,
    val category: String
)

class WordsDataStore(context: Context) {

    private val prefs: SharedPreferences = context.getSharedPreferences(
        "words_storage",
        Context.MODE_PRIVATE
    )
    private val gson = Gson()

    fun saveWords(words: List<WordData>) {
        val json = gson.toJson(words)
        prefs.edit().putString("all_words", json).apply()
    }

    fun getAllWords(): List<WordData> {
        val json = prefs.getString("all_words", "[]") ?: "[]"
        val type = object : TypeToken<List<WordData>>() {}.type
        return gson.fromJson(json, type)
    }

    fun getWordsByCategories(categories: List<String>): List<WordData> {
        return getAllWords().filter { word ->
            categories.contains(word.category)
        }
    }

    fun saveCategories(categories: List<String>) {
        val json = gson.toJson(categories)
        prefs.edit().putString("categories", json).apply()
    }

    fun saveWordsPerBurst(count: Int) {
        prefs.edit().putInt("words_per_burst", count).apply()
    }

    fun saveNickname(nickname: String) {
        prefs.edit().putString("nickname", nickname).apply()
    }

    fun getNickname(): String {
        return prefs.getString("nickname", "Usuario") ?: "Usuario"
    }

    fun getWordsPerBurst(): Int {
        return prefs.getInt("words_per_burst", 2)
    }
}
```

---

#### Archivo 2.2: NotificationHelper.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/NotificationHelper.kt`
**QUÉ HACE:** Crea las notificaciones visuales con palabra + significado
**DATOS QUE USA:**
- nickname (del wizard)
- word + meaning (de la base de datos)
- window (morning/afternoon/evening)

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.vocabox.hermes.MainActivity
import com.vocabox.hermes.R

object NotificationHelper {

    private const val CHANNEL_ID = "daily_study_channel"
    private const val CHANNEL_NAME = "Estudio Diario"
    private const val CHANNEL_DESCRIPTION = "Notificaciones para aprender palabras diarias"

    fun createNotificationChannel(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, importance).apply {
                description = CHANNEL_DESCRIPTION
                enableLights(true)
                enableVibration(true)
            }

            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE)
                as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    fun showNotification(
        context: Context,
        notificationId: Int,
        window: String,
        nickname: String,
        word: String,
        meaning: String,
        allWords: List<WordData>
    ) {
        createNotificationChannel(context)

        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            putExtra("notification_data", true)
            putExtra("window", window)
            putExtra("words_json", wordsToJson(allWords))
        }

        val pendingIntent = PendingIntent.getActivity(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // Título personalizado según ventana
        val title = when (window) {
            "morning" -> "¡Buenos días, $nickname! 🌅"
            "afternoon" -> "¡Buenas tardes, $nickname! ☀️"
            "evening" -> "¡Buenas noches, $nickname! 🌙"
            else -> "¡Hola, $nickname! 👋"
        }

        // Cuerpo: palabra = significado
        val body = "📚 $word = $meaning"

        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_REMINDER)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()

        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE)
            as NotificationManager
        notificationManager.notify(notificationId, notification)
    }

    private fun wordsToJson(words: List<WordData>): String {
        return words.joinToString(separator = ",", prefix = "[", postfix = "]") { word ->
            """{"id":"${word.id}","word":"${word.word}","meaning":"${word.meaning}","category":"${word.category}"}"""
        }
    }
}
```

**NOTA:** Debes crear el ícono `ic_notification.xml` en `android/app/src/main/res/drawable/`

---

#### Archivo 2.3: NotificationScheduler.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/NotificationScheduler.kt`
**QUÉ HACE:** Programa alarmas exactas con AlarmManager
**DATOS QUE USA:**
- active_windows (del wizard)
- window_times (del wizard: "08:00", "14:00", "20:00")
- categories (del wizard)
- words_per_burst (calculado en wizard)
- nickname (del wizard)

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import java.util.*

class NotificationScheduler(private val context: Context) {

    private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    private val TAG = "NotificationScheduler"

    fun scheduleExactAlarm(
        notificationId: Int,
        window: String,
        hour: Int,
        minute: Int,
        categories: List<String>,
        wordsPerBurst: Int,
        nickname: String
    ) {
        val calendar = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)

            // Si la hora ya pasó hoy, programar para mañana
            if (timeInMillis <= System.currentTimeMillis()) {
                add(Calendar.DAY_OF_YEAR, 1)
            }
        }

        val intent = Intent(context, NotificationReceiver::class.java).apply {
            action = "com.vocabox.hermes.SHOW_NOTIFICATION"
            putExtra("notification_id", notificationId)
            putExtra("window", window)
            putExtra("hour", hour)
            putExtra("minute", minute)
            putExtra("categories", categories.toTypedArray())
            putExtra("words_per_burst", wordsPerBurst)
            putExtra("nickname", nickname)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // setExactAndAllowWhileIdle ignora Doze mode y optimización de batería
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        }

        Log.d(TAG, "Scheduled exact alarm for $window at $hour:$minute (ID: $notificationId)")
    }

    fun cancelAllNotifications() {
        val windows = listOf("morning", "afternoon", "evening")

        windows.forEach { window ->
            val notificationId = window.hashCode()
            val intent = Intent(context, NotificationReceiver::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                notificationId,
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            alarmManager.cancel(pendingIntent)
            pendingIntent.cancel()
            Log.d(TAG, "Cancelled alarm for $window (ID: $notificationId)")
        }
    }
}
```

---

#### Archivo 2.4: NotificationReceiver.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/NotificationReceiver.kt`
**QUÉ HACE:** Recibe la alarma, selecciona palabras y muestra notificación
**FLUJO:**
1. Recibe alarma de AlarmManager
2. Lee palabras de SharedPreferences filtradas por categories
3. Selecciona N palabras aleatorias (words_per_burst)
4. Muestra notificación con primera palabra
5. Reprograma alarma para mañana

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import java.util.*

class NotificationReceiver : BroadcastReceiver() {

    private val TAG = "NotificationReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        Log.d(TAG, "onReceive triggered: ${intent.action}")

        when (intent.action) {
            "com.vocabox.hermes.SHOW_NOTIFICATION" -> {
                handleShowNotification(context, intent)
            }
        }
    }

    private fun handleShowNotification(context: Context, intent: Intent) {
        val notificationId = intent.getIntExtra("notification_id", 0)
        val window = intent.getStringExtra("window") ?: "morning"
        val hour = intent.getIntExtra("hour", 8)
        val minute = intent.getIntExtra("minute", 0)
        val categories = intent.getStringArrayExtra("categories")?.toList() ?: emptyList()
        val wordsPerBurst = intent.getIntExtra("words_per_burst", 2)
        val nickname = intent.getStringExtra("nickname") ?: "Usuario"

        Log.d(TAG, "Showing notification for window: $window at $hour:$minute")

        // Obtener palabras del almacenamiento local
        val wordsStore = WordsDataStore(context)
        val availableWords = wordsStore.getWordsByCategories(categories)

        // Seleccionar palabras aleatorias
        val selectedWords = availableWords
            .shuffled()
            .take(wordsPerBurst)

        if (selectedWords.isEmpty()) {
            Log.w(TAG, "No words available for categories: $categories")
            NotificationHelper.showNotification(
                context = context,
                notificationId = notificationId,
                window = window,
                nickname = nickname,
                word = "vocabulary",
                meaning = "vocabulario",
                allWords = emptyList()
            )
        } else {
            val firstWord = selectedWords[0]
            NotificationHelper.showNotification(
                context = context,
                notificationId = notificationId,
                window = window,
                nickname = nickname,
                word = firstWord.word,
                meaning = firstWord.meaning,
                allWords = selectedWords
            )
        }

        // RE-PROGRAMAR la alarma para mañana
        reprogramAlarmForTomorrow(context, intent, notificationId, hour, minute)
    }

    private fun reprogramAlarmForTomorrow(
        context: Context,
        originalIntent: Intent,
        notificationId: Int,
        hour: Int,
        minute: Int
    ) {
        val calendar = Calendar.getInstance().apply {
            add(Calendar.DAY_OF_YEAR, 1)
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }

        val newIntent = Intent(originalIntent)

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            newIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        }

        Log.d(TAG, "Rescheduled alarm for tomorrow at $hour:$minute")
    }
}
```

---

#### Archivo 2.5: BootReceiver.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/BootReceiver.kt`
**QUÉ HACE:** Reprograma alarmas cuando el dispositivo se reinicia
**PENDIENTE:** Requiere leer configuración guardada y reprogramar

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log

class BootReceiver : BroadcastReceiver() {

    private val TAG = "BootReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED ||
            intent.action == "android.intent.action.QUICKBOOT_POWERON") {

            Log.d(TAG, "Device booted, rescheduling notifications")

            // TODO: Leer configuración guardada y reprogramar alarmas
            // Esto se implementará en una fase posterior
        }
    }
}
```

---

#### Archivo 2.6: NotificationModule.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/notifications/NotificationModule.kt`
**QUÉ HACE:** Bridge entre React Native y Kotlin
**MÉTODOS EXPUESTOS A JS:**
- scheduleNotifications(settings)
- cancelAllNotifications()
- saveWords(words)
- requestIgnoreBatteryOptimization()
- checkExactAlarmPermission()
- requestExactAlarmPermission()

**DATOS QUE RECIBE DE REACT NATIVE:**
```javascript
settings = {
  categories: ["technology", "business"],
  active_windows: ["morning", "evening"],
  window_times: { morning: "08:00", evening: "20:00" },
  words_per_burst: 3,
  nickname: "María"
}
```

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.Intent
import android.net.Uri
import android.os.Build
import android.provider.Settings
import com.facebook.react.bridge.*

class NotificationModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    private val scheduler = NotificationScheduler(reactContext)
    private val wordsStore = WordsDataStore(reactContext)

    override fun getName(): String = "NotificationModule"

    @ReactMethod
    fun scheduleNotifications(settings: ReadableMap, promise: Promise) {
        try {
            scheduler.cancelAllNotifications()

            val categories = settings.getArray("categories")?.toArrayList() as? List<String>
                ?: emptyList()
            val activeWindows = settings.getArray("active_windows")?.toArrayList() as? List<String>
                ?: emptyList()
            val windowTimes = settings.getMap("window_times")
            val wordsPerBurst = settings.getInt("words_per_burst")
            val nickname = settings.getString("nickname") ?: "Usuario"

            wordsStore.saveCategories(categories)
            wordsStore.saveWordsPerBurst(wordsPerBurst)
            wordsStore.saveNickname(nickname)

            var scheduledCount = 0
            activeWindows.forEach { window ->
                val timeStr = windowTimes?.getString(window)
                if (timeStr != null) {
                    val (hour, minute) = timeStr.split(":").map { it.toInt() }
                    val notificationId = window.hashCode()

                    scheduler.scheduleExactAlarm(
                        notificationId = notificationId,
                        window = window,
                        hour = hour,
                        minute = minute,
                        categories = categories,
                        wordsPerBurst = wordsPerBurst,
                        nickname = nickname
                    )

                    scheduledCount++
                }
            }

            promise.resolve("Scheduled $scheduledCount notifications")
        } catch (e: Exception) {
            promise.reject("SCHEDULE_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun cancelAllNotifications(promise: Promise) {
        try {
            scheduler.cancelAllNotifications()
            promise.resolve("All notifications cancelled")
        } catch (e: Exception) {
            promise.reject("CANCEL_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun requestIgnoreBatteryOptimization(promise: Promise) {
        try {
            val activity = currentActivity
            if (activity == null) {
                promise.reject("NO_ACTIVITY", "Activity not available")
                return
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val packageName = reactApplicationContext.packageName
                val intent = Intent().apply {
                    action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
                    data = Uri.parse("package:$packageName")
                }
                activity.startActivity(intent)
                promise.resolve("Battery optimization dialog opened")
            } else {
                promise.resolve("Not needed for this Android version")
            }
        } catch (e: Exception) {
            promise.reject("BATTERY_OPT_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun checkExactAlarmPermission(promise: Promise) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val alarmManager = reactApplicationContext
                    .getSystemService(android.content.Context.ALARM_SERVICE) as android.app.AlarmManager
                val canSchedule = alarmManager.canScheduleExactAlarms()
                promise.resolve(canSchedule)
            } else {
                promise.resolve(true)
            }
        } catch (e: Exception) {
            promise.reject("PERMISSION_CHECK_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun requestExactAlarmPermission(promise: Promise) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                reactApplicationContext.startActivity(intent)
                promise.resolve("Permission dialog opened")
            } else {
                promise.resolve("Not needed for this Android version")
            }
        } catch (e: Exception) {
            promise.reject("PERMISSION_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun saveWords(wordsArray: ReadableArray, promise: Promise) {
        try {
            val words = mutableListOf<WordData>()
            for (i in 0 until wordsArray.size()) {
                val wordMap = wordsArray.getMap(i)
                if (wordMap != null) {
                    words.add(WordData(
                        id = wordMap.getString("id") ?: "",
                        word = wordMap.getString("word") ?: "",
                        meaning = wordMap.getString("meaning") ?: "",
                        category = wordMap.getString("category") ?: ""
                    ))
                }
            }
            wordsStore.saveWords(words)
            promise.resolve("Saved ${words.size} words")
        } catch (e: Exception) {
            promise.reject("SAVE_WORDS_ERROR", e.message, e)
        }
    }
}
```

---

### FASE 3: REGISTRAR MÓDULO EN REACT NATIVE

#### Archivo 3.1: MainApplication.kt
**UBICACIÓN:** `android/app/src/main/java/com/awesome/MainApplication.kt`
**QUÉ HACE:** Registra NotificationModule para que React Native lo reconozca
**MODIFICAR:**

```kotlin
package com.vocabox.hermes

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.soloader.SoLoader
import com.vocabox.hermes.notifications.NotificationModule      // AGREGAR
import com.vocabox.hermes.notifications.NotificationHelper     // AGREGAR
import com.facebook.react.bridge.ReactApplicationContext // AGREGAR

class MainApplication : Application(), ReactApplication {

    override val reactNativeHost: ReactNativeHost =
        object : DefaultReactNativeHost(this) {
            override fun getPackages(): List<ReactPackage> =
                PackageList(this).packages.apply {
                    // AGREGAR el paquete de notificaciones
                    add(object : ReactPackage {
                        override fun createNativeModules(reactContext: ReactApplicationContext) =
                            listOf(NotificationModule(reactContext))

                        override fun createViewManagers(reactContext: ReactApplicationContext) =
                            emptyList<com.facebook.react.uimanager.ViewManager<*, *>>()
                    })
                }

            override fun getJSMainModuleName(): String = "index"
            override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG
            override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
            override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
        }

    override val reactHost: ReactHost
        get() = getDefaultReactHost(applicationContext, reactNativeHost)

    override fun onCreate() {
        super.onCreate()
        SoLoader.init(this, false)
        if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
            load()
        }

        // AGREGAR: Crear canal de notificaciones
        NotificationHelper.createNotificationChannel(this)
    }
}
```

---

### FASE 4: BRIDGE REACT NATIVE (TYPESCRIPT)

#### Archivo 4.1: src/services/notificationService.ts
**QUÉ HACE:** Tipado TypeScript del módulo nativo
**CREAR ARCHIVO:**

```typescript
import { NativeModules } from 'react-native'

interface NotificationModuleInterface {
  scheduleNotifications(settings: {
    categories: string[]
    active_windows: string[]
    window_times: {
      morning?: string
      afternoon?: string
      evening?: string
    }
    words_per_burst: number
    nickname: string
  }): Promise<string>

  cancelAllNotifications(): Promise<string>
  requestIgnoreBatteryOptimization(): Promise<string>
  checkExactAlarmPermission(): Promise<boolean>
  requestExactAlarmPermission(): Promise<string>
  saveWords(words: Array<{
    id: string
    word: string
    meaning: string
    category: string
  }>): Promise<string>
}

const { NotificationModule } = NativeModules
export default NotificationModule as NotificationModuleInterface
```

---

#### Archivo 4.2: src/hooks/useNotifications.ts
**QUÉ HACE:** Hook para programar notificaciones desde React Native
**DATOS QUE LEE:** Todos los del wizard desde Redux
**CREAR ARCHIVO:**

```typescript
import { useEffect } from 'react'
import { useSelector } from 'react-redux'
import { RootState } from '@/store/store'
import NotificationModule from '@/services/notificationService'
import { supabase } from '@/services/supebase'

export function useNotifications() {
  const settings = useSelector((state: RootState) => state.settings.data)
  const wizardCompleted = settings.wizard_completed

  useEffect(() => {
    if (wizardCompleted) {
      setupNotifications()
    }
  }, [wizardCompleted])

  const setupNotifications = async () => {
    try {
      console.log('Setting up notifications with settings:', settings)

      // 1. Verificar permisos de alarmas exactas (Android 12+)
      const canSchedule = await NotificationModule.checkExactAlarmPermission()
      if (!canSchedule) {
        console.log('Requesting exact alarm permission...')
        await NotificationModule.requestExactAlarmPermission()
        return
      }

      // 2. Solicitar ignorar optimización de batería
      await NotificationModule.requestIgnoreBatteryOptimization()

      // 3. Obtener palabras de Supabase filtradas por categorías
      const { data: words, error } = await supabase
        .from('words')
        .select('*')
        .in('category', settings.categories || [])
        .limit(100)

      if (error) {
        console.error('Error fetching words:', error)
        return
      }

      // 4. Guardar palabras en almacenamiento nativo
      if (words && words.length > 0) {
        await NotificationModule.saveWords(words)
        console.log(`Saved ${words.length} words to native storage`)
      }

      // 5. Programar notificaciones con configuración del wizard
      const result = await NotificationModule.scheduleNotifications({
        categories: settings.categories || [],
        active_windows: settings.active_windows || ['morning'],
        window_times: settings.window_times || { morning: '08:00' },
        words_per_burst: settings.words_per_burst || 2,
        nickname: settings.nickname || 'Usuario'
      })

      console.log('Notifications scheduled:', result)
    } catch (error) {
      console.error('Error setting up notifications:', error)
    }
  }

  return {
    setupNotifications
  }
}
```

---

### FASE 5: INTEGRACIÓN CON WIZARD

#### Archivo 5.1: Llamar setupNotifications al completar wizard
**UBICACIÓN:** `src/viewmodels/useWizardViewModel.ts`
**MODIFICAR la función `saveAndComplete`:**

```typescript
import { useNotifications } from '@/hooks/useNotifications'

export const useWizardViewModel = () => {
  // ... código existente

  const { setupNotifications } = useNotifications()

  const saveAndComplete = useCallback(async () => {
    const currentUser = userRef.current
    const currentData = dataRef.current

    if (!currentUser) {
      console.log('No user found')
      return false
    }

    try {
      dispatch(wizardSaveStart())

      const settingsToSave = {
        ...currentData,
        user_id: currentUser.id,
        wizard_completed: true
      }

      console.log('Saving settings:', JSON.stringify(settingsToSave, null, 2))

      const result = await upsertSettings(settingsToSave as any)
      console.log('Settings saved successfully:', result)

      dispatch(completeWizard())
      dispatch(wizardSaveSuccess(result))

      // AGREGAR: Programar notificaciones
      await setupNotifications()

      navigation.dispatch(
        CommonActions.reset({
          index: 0,
          routes: [{ name: 'Main' }],
        })
      )

      return true
    } catch (error) {
      // ... manejo de errores existente
    }
  }, [dispatch, navigation, setupNotifications])

  // ... resto del código
}
```

---

## 5. FLUJO DE DATOS COMPLETO
## ===========================

### Paso 1: Usuario completa el Wizard
```
StepNameMotivation → nickname: "María"
StepCategories → categories: ["technology", "business"]
StepWeeklyTarget → weekly_words_target: 30 → daily_words: 5
StepBurstsAndTimes → bursts_per_day: 2, active_windows: ["morning", "evening"]
                   → window_times: { morning: "08:00", evening: "20:00" }
                   → words_per_burst: 3
```

### Paso 2: Datos se guardan en Redux
```
Redux Store (state.settings.data)
├── nickname: "María"
├── categories: ["technology", "business"]
├── weekly_words_target: 30
├── daily_words: 5
├── bursts_per_day: 2
├── active_windows: ["morning", "evening"]
├── window_times: { morning: "08:00", evening: "20:00" }
├── words_per_burst: 3
└── wizard_completed: true
```

### Paso 3: Guardar en Supabase
```
upsertSettings(settings) → tabla user_settings
```

### Paso 4: useNotifications() se ejecuta automáticamente
```typescript
// Detecta wizard_completed === true
useEffect(() => {
  if (wizardCompleted) {
    setupNotifications()
  }
}, [wizardCompleted])
```

### Paso 5: setupNotifications() ejecuta
```
1. Verificar permisos → checkExactAlarmPermission()
2. Solicitar batería → requestIgnoreBatteryOptimization()
3. Obtener palabras de Supabase filtradas por categories
4. Guardar palabras en Kotlin → saveWords(words)
5. Programar notificaciones → scheduleNotifications({
     categories: ["technology", "business"],
     active_windows: ["morning", "evening"],
     window_times: { morning: "08:00", evening: "20:00" },
     words_per_burst: 3,
     nickname: "María"
   })
```

### Paso 6: NotificationModule.kt recibe datos
```kotlin
scheduleNotifications(settings) {
  // Cancelar notificaciones anteriores
  // Para cada ventana activa:
  //   - Programar alarma exacta con AlarmManager
  //   - ID único por ventana
  //   - Guardar configuración en SharedPreferences
}
```

### Paso 7: AlarmManager programa alarmas
```
Alarma 1: ID = "morning".hashCode()
  - Hora: 08:00 AM
  - Datos: categories, words_per_burst, nickname

Alarma 2: ID = "evening".hashCode()
  - Hora: 20:00 PM (8:00 PM)
  - Datos: categories, words_per_burst, nickname
```

### Paso 8: A las 08:00 AM, AlarmManager dispara NotificationReceiver
```kotlin
NotificationReceiver.onReceive() {
  1. Lee palabras de SharedPreferences
  2. Filtra por categories: ["technology", "business"]
  3. Selecciona 3 palabras aleatorias (words_per_burst)
  4. Toma la primera palabra: { word: "achievement", meaning: "logro" }
  5. Muestra notificación:
     Título: "¡Buenos días, María! 🌅"
     Cuerpo: "📚 achievement = logro"
  6. Reprograma alarma para mañana a las 08:00 AM
}
```

### Paso 9: Usuario toca la notificación
```
Intent abre MainActivity con extras:
- notification_data: true
- window: "morning"
- words_json: [{"word":"achievement","meaning":"logro"}, ...]

React Native puede leer estos datos y navegar a pantalla de estudio
```

---

## 6. RESUMEN DE IMPLEMENTACIÓN
## =============================

### Archivos a crear (total: 11)

**Android Kotlin (6 archivos):**
1. ✅ WordsDataStore.kt
2. ✅ NotificationHelper.kt
3. ✅ NotificationScheduler.kt
4. ✅ NotificationReceiver.kt
5. ✅ BootReceiver.kt
6. ✅ NotificationModule.kt

**Android modificar (3 archivos):**
7. ✅ AndroidManifest.xml
8. ✅ build.gradle
9. ✅ MainApplication.kt

**React Native TypeScript (2 archivos):**
10. ✅ src/services/notificationService.ts
11. ✅ src/hooks/useNotifications.ts

**React Native modificar (1 archivo):**
12. ✅ src/viewmodels/useWizardViewModel.ts

### Características finales:
- ✅ Notificaciones EXACTAS con AlarmManager
- ✅ Funciona con app cerrada/muerta
- ✅ Ignora optimización de batería y Doze mode
- ✅ Muestra palabra + significado
- ✅ Filtra por categorías del wizard
- ✅ Usa nickname del wizard
- ✅ Respeta horarios del wizard
- ✅ Se reprograma automáticamente cada día
- ✅ Persiste al reiniciar dispositivo

### Datos del wizard utilizados:
1. ✅ nickname → Título de notificación
2. ✅ categories → Filtrar palabras
3. ✅ active_windows → Cuántas notificaciones/día
4. ✅ window_times → Horarios exactos
5. ✅ words_per_burst → Cuántas palabras mostrar

---

## 7. CASOS DE USO PARA PRUEBAS
## ================================

### 7.1. VERIFICACIÓN ACTUAL DEL CÓDIGO

#### ✅ SÍ filtra por categorías seleccionadas
**Ubicación:** `NotificationReceiver.kt:39`
```kotlin
val availableWords = wordsStore.getWordsByCategories(categories)
```
- Las categorías vienen del wizard
- Solo muestra palabras de esas categorías
- Si no hay palabras, muestra "vocabulary = vocabulario" por defecto

#### ✅ SÍ respeta horarios configurados
**Ubicación:** `NotificationScheduler.kt:25-35`
```kotlin
val calendar = Calendar.getInstance().apply {
    set(Calendar.HOUR_OF_DAY, hour)  // Hora del wizard
    set(Calendar.MINUTE, minute)      // Minuto del wizard
}
```

#### ✅ SÍ selecciona múltiples palabras por notificación
**Ubicación:** `NotificationReceiver.kt:42-44`
```kotlin
val selectedWords = availableWords
    .shuffled()
    .take(wordsPerBurst)  // Cantidad del wizard
```
- Actualmente solo muestra la primera palabra en la notificación
- Las demás se envían al Intent para uso en la app

#### ✅ SÍ se reprograma automáticamente
**Ubicación:** `NotificationReceiver.kt:71 y 81-87`
```kotlin
reprogramAlarmForTomorrow() {
    add(Calendar.DAY_OF_YEAR, 1)  // Mañana mismo horario
}
```

---

### 7.2. CÓMO AFECTA CADA CONFIGURACIÓN DEL WIZARD

#### PASO 2: StepNameMotivation
**Campo:** `nickname`
**Valor ejemplo:** "María"
**Impacto en notificaciones:**
- ✅ Aparece en el título de la notificación
- Título morning: "¡Buenos días, María! 🌅"
- Título afternoon: "¡Buenas tardes, María! ☀️"
- Título evening: "¡Buenas noches, María! 🌙"

**Código:** `NotificationHelper.kt:334-339`

---

#### PASO 3: StepCategories
**Campo:** `categories`
**Valor ejemplo:** `["technology", "business", "science"]`
**Impacto en notificaciones:**
- ✅ Filtra palabras SOLO de esas categorías
- ✅ Si seleccionas 3 categorías, todas las palabras mostradas serán de esas 3
- ⚠️ Si no hay palabras en esas categorías, muestra "vocabulary = vocabulario"

**Código:** `NotificationReceiver.kt:31 y 39`
```kotlin
val categories = intent.getStringArrayExtra("categories")?.toList() ?: emptyList()
val availableWords = wordsStore.getWordsByCategories(categories)
```

**Prueba:**
1. Selecciona SOLO "technology" en el wizard
2. Completa wizard
3. Verifica que todas las notificaciones sean palabras de tecnología

---

#### PASO 4: StepWeeklyTarget
**Campo:** `weekly_words_target`
**Valor ejemplo:** 30 palabras/semana
**Cálculo automático:** `daily_words = ceil(30/7) = 5`
**Impacto en notificaciones:**
- ❌ NO afecta directamente las notificaciones
- ✅ Se usa solo para calcular `words_per_burst`

---

#### PASO 5: StepBurstsAndTimes
**Campo 1:** `bursts_per_day`
**Valor ejemplo:** 2 (dos veces al día)
**Impacto:**
- ✅ Determina CUÁNTAS notificaciones recibirás al día
- Si seleccionas 1 → 1 notificación/día
- Si seleccionas 2 → 2 notificaciones/día
- Si seleccionas 3 → 3 notificaciones/día

**Código:** `NotificationModule.kt:46-64`
```kotlin
activeWindows.forEach { window ->
    // Programa UNA alarma por cada ventana activa
}
```

**Prueba:**
- `bursts_per_day: 1` + `active_windows: ["morning"]` = 1 notificación a las 08:00
- `bursts_per_day: 2` + `active_windows: ["morning", "evening"]` = 2 notificaciones
- `bursts_per_day: 3` + `active_windows: ["morning", "afternoon", "evening"]` = 3 notificaciones

---

**Campo 2:** `active_windows`
**Valor ejemplo:** `["morning", "evening"]`
**Impacto:**
- ✅ Define EN QUÉ MOMENTOS del día recibes notificaciones
- morning → mañana
- afternoon → tarde
- evening → noche

**Código:** `NotificationModule.kt:46`

---

**Campo 3:** `window_times`
**Valor ejemplo:** `{ morning: "08:00", evening: "20:00" }`
**Impacto:**
- ✅ Define LA HORA EXACTA de cada notificación
- "08:00" → 8:00 AM
- "20:00" → 8:00 PM (20:00 en formato 24h)

**Código:** `NotificationScheduler.kt:26-27`

**Prueba:**
1. Configura: `window_times: { morning: "09:30" }`
2. La notificación llegará EXACTAMENTE a las 9:30 AM
3. Si la hora ya pasó hoy, se programa para mañana

---

**Campo 4:** `words_per_burst`
**Cálculo:** `ceil(daily_words / bursts_per_day)`
**Ejemplo:**
- `daily_words: 5` + `bursts_per_day: 2` = `words_per_burst: 3`
- `daily_words: 6` + `bursts_per_day: 3` = `words_per_burst: 2`

**Impacto:**
- ✅ Cuántas palabras se seleccionan aleatoriamente
- ⚠️ ACTUALMENTE solo muestra la primera palabra en la notificación
- ✅ Las demás se envían al Intent para mostrar en la app

**Código:** `NotificationReceiver.kt:42-44`
```kotlin
val selectedWords = availableWords
    .shuffled()           // Mezcla todas las palabras
    .take(wordsPerBurst)  // Toma N palabras (ej: 3)

// Pero solo muestra la primera en la notificación
val firstWord = selectedWords[0]
```

---

### 7.3. CASOS DE USO PARA PRUEBAS

#### CASO 1: Configuración Básica (1 notificación diaria)
**Configuración del Wizard:**
```javascript
{
  nickname: "Juan",
  categories: ["technology"],
  weekly_words_target: 10,
  bursts_per_day: 1,
  active_windows: ["morning"],
  window_times: { morning: "09:00" }
}
```

**Resultado esperado:**
- ✅ 1 notificación al día
- ✅ A las 9:00 AM exactamente
- ✅ Título: "¡Buenos días, Juan! 🌅"
- ✅ Cuerpo: "📚 [palabra de technology] = [significado]"
- ✅ Palabras SOLO de categoría "technology"
- ✅ Se repite todos los días a las 9:00 AM

**Cálculos:**
- `daily_words = ceil(10/7) = 2`
- `words_per_burst = ceil(2/1) = 2`
- Se seleccionan 2 palabras, se muestra 1 en notificación

---

#### CASO 2: Configuración Moderada (2 notificaciones diarias)
**Configuración del Wizard:**
```javascript
{
  nickname: "Ana",
  categories: ["business", "science"],
  weekly_words_target: 30,
  bursts_per_day: 2,
  active_windows: ["morning", "evening"],
  window_times: {
    morning: "08:00",
    evening: "19:00"
  }
}
```

**Resultado esperado:**
- ✅ 2 notificaciones al día
- ✅ Primera a las 8:00 AM
  - Título: "¡Buenos días, Ana! 🌅"
  - Palabras de "business" o "science" (aleatorio)
- ✅ Segunda a las 19:00 (7:00 PM)
  - Título: "¡Buenas noches, Ana! 🌙"
  - Palabras de "business" o "science" (aleatorio)
- ✅ Diferentes palabras en cada notificación (shuffled)

**Cálculos:**
- `daily_words = ceil(30/7) = 5`
- `words_per_burst = ceil(5/2) = 3`
- Se seleccionan 3 palabras por notificación, se muestra 1

---

#### CASO 3: Configuración Intensiva (3 notificaciones diarias)
**Configuración del Wizard:**
```javascript
{
  nickname: "Carlos",
  categories: ["technology", "business", "science", "arts"],
  weekly_words_target: 50,
  bursts_per_day: 3,
  active_windows: ["morning", "afternoon", "evening"],
  window_times: {
    morning: "07:00",
    afternoon: "13:00",
    evening: "20:30"
  }
}
```

**Resultado esperado:**
- ✅ 3 notificaciones al día
- ✅ 7:00 AM → "¡Buenos días, Carlos! 🌅"
- ✅ 13:00 (1:00 PM) → "¡Buenas tardes, Carlos! ☀️"
- ✅ 20:30 (8:30 PM) → "¡Buenas noches, Carlos! 🌙"
- ✅ Palabras de 4 categorías mezcladas
- ✅ Mayor variedad de palabras

**Cálculos:**
- `daily_words = ceil(50/7) = 8`
- `words_per_burst = ceil(8/3) = 3`
- Se seleccionan 3 palabras por notificación

---

#### CASO 4: Prueba de Filtrado de Categorías
**Objetivo:** Verificar que SOLO muestra palabras de las categorías seleccionadas

**Pasos:**
1. Completa wizard con SOLO 1 categoría: `["technology"]`
2. Asegúrate de tener palabras en Supabase de esa categoría
3. Espera la notificación
4. Verifica que la palabra mostrada sea de "technology"
5. Repite varias veces para confirmar

**Código responsable:**
```kotlin
// NotificationReceiver.kt:39
val availableWords = wordsStore.getWordsByCategories(categories)
```

---

#### CASO 5: Prueba de Horarios Exactos
**Objetivo:** Verificar que las notificaciones llegan a la hora exacta

**Pasos:**
1. Configura: `window_times: { morning: "14:35" }` (hora 5 minutos en el futuro)
2. Completa wizard
3. Espera hasta las 14:35
4. La notificación debe llegar EXACTAMENTE a esa hora (±1 minuto por sistema)

**Nota:** Si la hora ya pasó, se programa para mañana
```kotlin
// NotificationScheduler.kt:32-34
if (timeInMillis <= System.currentTimeMillis()) {
    add(Calendar.DAY_OF_YEAR, 1)
}
```

---

#### CASO 6: Prueba de Reprogramación Automática
**Objetivo:** Verificar que se reprograma cada día

**Pasos:**
1. Configura notificación para mañana
2. Espera a que llegue la notificación
3. Verifica en los logs de Logcat:
```
NotificationReceiver: Rescheduled alarm for tomorrow at HH:mm
```
4. Confirma que al día siguiente llega de nuevo

**Código responsable:**
```kotlin
// NotificationReceiver.kt:74-115
reprogramAlarmForTomorrow()
```

---

#### CASO 7: Prueba sin Palabras en Categorías
**Objetivo:** Verificar fallback cuando no hay palabras

**Pasos:**
1. Configura categorías que NO existen en Supabase: `["fake_category"]`
2. Completa wizard
3. Espera notificación
4. Debe mostrar: "📚 vocabulary = vocabulario"

**Código responsable:**
```kotlin
// NotificationReceiver.kt:46-56
if (selectedWords.isEmpty()) {
    NotificationHelper.showNotification(
        word = "vocabulary",
        meaning = "vocabulario"
    )
}
```

---

### 7.4. TABLA RESUMEN: CONFIGURACIÓN → COMPORTAMIENTO

| Configuración | Valor Ejemplo | Impacto en Notificaciones |
|---------------|---------------|---------------------------|
| `nickname` | "María" | Personaliza título: "¡Buenos días, María! 🌅" |
| `categories` | ["technology", "science"] | Filtra palabras SOLO de esas categorías |
| `weekly_words_target` | 30 | NO afecta directamente, solo calcula daily_words |
| `daily_words` | 5 | NO afecta directamente, solo calcula words_per_burst |
| `bursts_per_day` | 2 | Define CANTIDAD de notificaciones al día (1, 2 o 3) |
| `active_windows` | ["morning", "evening"] | Define CUÁNDO llegan (mañana, tarde, noche) |
| `window_times.morning` | "08:00" | Hora EXACTA de notificación de mañana |
| `window_times.afternoon` | "14:00" | Hora EXACTA de notificación de tarde |
| `window_times.evening` | "20:00" | Hora EXACTA de notificación de noche |
| `words_per_burst` | 3 | Cuántas palabras se seleccionan (se muestra 1) |

---

### 7.5. TABLA DE HORARIOS POR VENTANA

| Ventana | Emoji | Saludo | Horarios Disponibles | Formato |
|---------|-------|--------|----------------------|---------|
| `morning` | 🌅 | "¡Buenos días, {nickname}!" | 06:00 - 11:00 (6am - 11am) | 24h |
| `afternoon` | ☀️ | "¡Buenas tardes, {nickname}!" | 12:00 - 18:00 (12pm - 6pm) | 24h |
| `evening` | 🌙 | "¡Buenas noches, {nickname}!" | 19:00 - 23:00 (7pm - 11pm) | 24h |

**Código UI:** `StepBurstsAndTimes.tsx:13-35`
**Código Notificaciones:** `NotificationHelper.kt:60-65`
**Código Scheduler:** `NotificationScheduler.kt:26-27` (usa HOUR_OF_DAY en formato 24h)

**COHERENCIA PERFECTA:**
- ✅ El formato es 24 horas: "20:00" = 8:00 PM
- ✅ Las notificaciones SÍ respetan AM/PM correctamente
- ✅ Cada ventana solo muestra horarios apropiados
- ✅ Los saludos coinciden EXACTAMENTE con las ventanas seleccionadas:
  - **morning** (06:00-11:00) → "¡Buenos días, {nickname}! 🌅"
  - **afternoon** (12:00-18:00) → "¡Buenas tardes, {nickname}! ☀️"
  - **evening** (19:00-23:00) → "¡Buenas noches, {nickname}! 🌙"

---

### 7.6. FRECUENCIA Y CANTIDAD

#### Ejemplo 1: Estudiante Ligero
```javascript
bursts_per_day: 1
active_windows: ["morning"]
weekly_words_target: 10
```
**Resultado:** 1 notificación/día = 7 notificaciones/semana = ~10 palabras/semana

---

#### Ejemplo 2: Estudiante Moderado
```javascript
bursts_per_day: 2
active_windows: ["morning", "evening"]
weekly_words_target: 30
```
**Resultado:** 2 notificaciones/día = 14 notificaciones/semana = ~30 palabras/semana

---

#### Ejemplo 3: Estudiante Intensivo
```javascript
bursts_per_day: 3
active_windows: ["morning", "afternoon", "evening"]
weekly_words_target: 50
```
**Resultado:** 3 notificaciones/día = 21 notificaciones/semana = ~50 palabras/semana

---

### 7.7. DEBUGGING EN LOGCAT

Para ver los logs de notificaciones, usa este filtro en Android Studio Logcat:

```
NotificationScheduler|NotificationReceiver|NotificationHelper|NotificationModule
```

**Logs importantes:**
```
NotificationScheduler: Scheduled exact alarm for morning at 8:0 (ID: 283283223)
NotificationScheduler: Next trigger: Sun Oct 05 08:00:00 GMT-06:00 2025

NotificationReceiver: onReceive triggered: com.vocabox.hermes.SHOW_NOTIFICATION
NotificationReceiver: Showing notification for window: morning at 8:0
NotificationReceiver: Rescheduled alarm for tomorrow at 8:0
```

---

### 7.8. CHECKLIST DE VERIFICACIÓN

Cuando completes el wizard, verifica:

- [ ] ✅ Se guardaron las palabras en SharedPreferences
  - Log: `Saved X words to native storage`
- [ ] ✅ Se programaron las alarmas
  - Log: `Scheduled X notifications`
- [ ] ✅ Las alarmas tienen la hora correcta
  - Log: `Next trigger: [fecha y hora]`
- [ ] ✅ La notificación muestra tu nickname
  - Título: "¡Buenos días, [TU_NICKNAME]! 🌅"
- [ ] ✅ La palabra es de las categorías seleccionadas
  - Verifica en Supabase que la palabra exista en tus categorías
- [ ] ✅ La notificación llega a la hora exacta configurada
  - Compara hora del sistema con `window_times`
- [ ] ✅ Se reprograma automáticamente
  - Log: `Rescheduled alarm for tomorrow`

---

### 7.9. PROBLEMAS COMUNES Y SOLUCIONES

#### Problema 1: No llegan notificaciones
**Causas posibles:**
1. ❌ No se concedió permiso SCHEDULE_EXACT_ALARM (Android 12+)
2. ❌ No se desactivó optimización de batería
3. ❌ No hay palabras en las categorías seleccionadas
4. ❌ La hora configurada ya pasó hoy (se programa para mañana)

**Solución:**
- Verifica logs de Logcat
- Confirma permisos en Settings → Apps → VocabloxApp → Permisos

---

#### Problema 2: Notificación muestra "vocabulary = vocabulario"
**Causa:**
- No hay palabras guardadas en SharedPreferences O
- No hay palabras en las categorías seleccionadas

**Solución:**
1. Verifica que existan palabras en Supabase tabla `words`
2. Verifica que tengan las categorías correctas
3. Revisa log: `Saved X words to native storage` (debe ser > 0)

---

#### Problema 3: Notificación no se repite al día siguiente
**Causa:**
- Error en reprogramAlarmForTomorrow()

**Solución:**
- Verifica log: `Rescheduled alarm for tomorrow at HH:mm`
- Si no aparece, hay un error en NotificationReceiver.kt

---

### 7.10. COMANDOS ADB PARA TESTING

#### Simular notificación inmediata (requiere modificación código):
```bash
adb shell am broadcast -a com.vocabox.hermes.SHOW_NOTIFICATION
```

#### Ver alarmas programadas:
```bash
adb shell dumpsys alarm | grep vocabox
```

#### Forzar Doze mode (probar que funciona con app cerrada):
```bash
adb shell dumpsys deviceidle force-idle
```

#### Ver SharedPreferences:
```bash
adb shell run-as com.vocabox.hermes cat /data/data/com.vocabox.hermes/shared_prefs/words_storage.xml
```

---

### 7.11. CONCLUSIÓN

**TU CÓDIGO YA IMPLEMENTA TODO CORRECTAMENTE:**

✅ Filtra por categorías (NotificationReceiver.kt:39)
✅ Respeta horarios exactos (NotificationScheduler.kt:26-27)
✅ Personaliza con nickname (NotificationHelper.kt:334-339)
✅ Selecciona múltiples palabras (NotificationReceiver.kt:42-44)
✅ Se reprograma automáticamente (NotificationReceiver.kt:74-115)
✅ Funciona con app cerrada (AlarmManager + BroadcastReceiver)
✅ Ignora Doze mode (setExactAndAllowWhileIdle)

**RECOMENDACIÓN PARA PRUEBAS RÁPIDAS:**
Como las notificaciones se programan para mañana si la hora ya pasó, te recomiendo configurar `window_times` con una hora 2-3 minutos en el futuro desde el momento actual para probar inmediatamente.

---

## 8. CAMBIOS RECIENTES DE COHERENCIA
## ====================================

### 8.1. CORRECCIÓN DE ETIQUETAS SEMANALES (StepWeeklyTarget.tsx)

**Problema anterior:**
- Mostraba "10 palabras/semana" pero realmente eran 14 (2×7)
- Mostraba "30 palabras/semana" pero realmente eran 35 (5×7)
- Mostraba "40 palabras/semana" pero realmente eran 42 (6×7)
- Mostraba "50 palabras/semana" pero realmente eran 56 (8×7)

**Solución aplicada:**
```javascript
// ANTES
{ value: 10, label: '10 palabras', dailyWords: 2 }

// AHORA
{ value: 10, label: '14 palabras', dailyWords: 2 }  // Honesto: 2×7=14 ✅
```

**Resultado:**
- ✅ Las etiquetas ahora reflejan la cantidad REAL de palabras
- ✅ El preview muestra cálculo correcto: `dailyWords * 7`
- ✅ Usuario sabe exactamente cuántas palabras aprenderá

---

### 8.2. HORARIOS ESPECÍFICOS POR VENTANA (StepBurstsAndTimes.tsx)

**Problema anterior:**
- Todas las ventanas mostraban los mismos horarios (06:00 - 23:00)
- Podías seleccionar "22:00" para "Mañana" ❌
- Podías seleccionar "07:00" para "Noche" ❌
- No había lógica de AM/PM en la UI

**Solución aplicada:**
```javascript
// ANTES (todas las ventanas compartían timeSlots)
const timeSlots = ['06:00', '07:00', ..., '23:00']

// AHORA (cada ventana tiene sus propios horarios)
{
  id: 'morning',
  name: 'Mañana',
  availableSlots: ['06:00', '07:00', '08:00', '09:00', '10:00', '11:00']
},
{
  id: 'afternoon',
  name: 'Tarde',
  availableSlots: ['12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00']
},
{
  id: 'evening',
  name: 'Noche',
  availableSlots: ['19:00', '20:00', '21:00', '22:00', '23:00', '00:00', '01:00']
}
```

**Resultado:**
- ✅ **Mañana** solo muestra 06:00 - 11:00 (6am - 11am)
- ✅ **Tarde** solo muestra 12:00 - 18:00 (12pm - 6pm)
- ✅ **Noche** solo muestra 19:00 - 01:00 (7pm - 1am)
- ✅ Imposible seleccionar horarios incoherentes
- ✅ Incluye medianoche (00:00) y madrugada (01:00) para noche

**Verificación técnica:**
```kotlin
// NotificationScheduler.kt usa formato 24h correctamente
set(Calendar.HOUR_OF_DAY, hour)  // ✅ Respeta AM/PM
set(Calendar.MINUTE, minute)

// Ejemplos:
"08:00" → hour=8  → 8:00 AM ✅
"20:00" → hour=20 → 8:00 PM ✅
"00:00" → hour=0  → 12:00 AM (medianoche) ✅
```

---

### 8.3. TABLA DE COHERENCIA FINAL

| Configuración Wizard | Notificación Programada | ¿Coherente? |
|---------------------|------------------------|-------------|
| **14 palabras/semana** → 2 palabras/día | `dailyWords = 2` | ✅ |
| **1 sesión** → morning:08:00 | 1 notificación a las 8:00 AM | ✅ |
| `words_per_burst = 2` | Selecciona 2 palabras, muestra 1 | ✅ |
| **Ventana: morning** | Solo horarios 06:00-11:00 | ✅ |
| **Ventana: afternoon** | Solo horarios 12:00-18:00 | ✅ |
| **Ventana: evening** | Solo horarios 19:00-01:00 | ✅ |
| Hora seleccionada: **20:00** | Notificación a las 8:00 PM | ✅ |
| Hora seleccionada: **00:00** | Notificación a las 12:00 AM | ✅ |

---

### 8.4. CASOS DE PRUEBA ACTUALIZADOS

#### CASO BÁSICO: 14 palabras/semana, 1 sesión, mañana 08:00
```javascript
{
  weekly_words_target: 10,  // valor interno
  daily_words: 2,            // calculado
  bursts_per_day: 1,
  active_windows: ["morning"],
  window_times: { morning: "08:00" },
  words_per_burst: 2         // calculado
}
```

**Resultado esperado:**
- ✅ Etiqueta UI: "14 palabras/semana"
- ✅ Preview: "2 palabras/día"
- ✅ Horarios morning: solo 06:00, 07:00, 08:00, 09:00, 10:00, 11:00
- ✅ Notificación: todos los días a las 8:00 AM
- ✅ Muestra 1 palabra por notificación (de 2 seleccionadas)

#### CASO MODERADO: 35 palabras/semana, 2 sesiones, morning:08:00 + evening:20:00
```javascript
{
  weekly_words_target: 30,
  daily_words: 5,
  bursts_per_day: 2,
  active_windows: ["morning", "evening"],
  window_times: { morning: "08:00", evening: "20:00" },
  words_per_burst: 3  // ceil(5/2) = 3
}
```

**Resultado esperado:**
- ✅ Etiqueta UI: "35 palabras/semana"
- ✅ Preview: "5 palabras/día"
- ✅ Horarios morning: solo 06:00-11:00
- ✅ Horarios evening: solo 19:00-01:00
- ✅ Notificación 1: 8:00 AM (morning) con 1 palabra
- ✅ Notificación 2: 8:00 PM (evening) con 1 palabra
- ✅ Total real: ~6 palabras/día × 7 = 42 palabras/semana

---

### 8.5. VERIFICACIÓN DE FORMATO AM/PM

**El sistema usa formato 24 horas PERO respeta correctamente AM/PM:**

| Hora UI | Formato interno | Hora real | Verificación |
|---------|----------------|-----------|--------------|
| 06:00 | hour=6, minute=0 | 6:00 AM | ✅ |
| 11:00 | hour=11, minute=0 | 11:00 AM | ✅ |
| 12:00 | hour=12, minute=0 | 12:00 PM (mediodía) | ✅ |
| 18:00 | hour=18, minute=0 | 6:00 PM | ✅ |
| 20:00 | hour=20, minute=0 | 8:00 PM | ✅ |
| 23:00 | hour=23, minute=0 | 11:00 PM | ✅ |
| 00:00 | hour=0, minute=0 | 12:00 AM (medianoche) | ✅ |
| 01:00 | hour=1, minute=0 | 1:00 AM | ✅ |

**Código responsable:**
```kotlin
// NotificationScheduler.kt:26
set(Calendar.HOUR_OF_DAY, hour)  // Usa sistema 24h de Java Calendar
// NO confundir con HOUR (que sería 12h y requeriría AM_PM)
```

---

### 8.6. RESUMEN DE MEJORAS

**✅ ANTES:**
- Etiquetas engañosas ("10 palabras" pero eran 14)
- Horarios sin restricción por ventana
- Confusión sobre AM/PM

**✅ AHORA:**
- Etiquetas honestas ("14 palabras" = 2×7)
- Horarios lógicos por ventana (mañana solo AM, noche solo PM)
- Formato 24h claro y correctamente interpretado
- Imposible configurar horarios incoherentes
- Sistema de notificaciones 100% coherente con UI
