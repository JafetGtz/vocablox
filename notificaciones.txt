# PLAN DE IMPLEMENTACI√ìN - NOTIFICACIONES NATIVAS CON KOTLIN
# =============================================================

## √çNDICE
## ======
1. DATOS DEL WIZARD (De d√≥nde provienen)
2. ARQUITECTURA DE ARCHIVOS
3. FASES DE IMPLEMENTACI√ìN
4. ORDEN DE CREACI√ìN DE ARCHIVOS
5. FLUJO DE DATOS COMPLETO


## 1. DATOS DEL WIZARD - ORIGEN Y UBICACI√ìN
## ==========================================

### 1.1. Valores capturados en el Wizard (Redux)

**Ubicaci√≥n en Redux:**
- Slice: `src/store/slices/settingsSlice.ts`
- State path: `state.settings.data`

**Valores disponibles:**

```typescript
interface UserSettings {
  // Paso 2: StepNameMotivation
  nickname: string                    // Ej: "Mar√≠a"
  motivational: string                // Ej: "Cada d√≠a una palabra nueva"

  // Paso 3: StepCategories
  categories: string[]                // Ej: ["technology", "business", "science"]

  // Paso 4: StepWeeklyTarget
  weekly_words_target: 10 | 30 | 40 | 50    // Ej: 30
  daily_words: number                 // CALCULADO: ceil(30/7) = 5

  // Paso 5: StepBurstsAndTimes
  bursts_per_day: 1 | 2 | 3          // Ej: 2
  active_windows: TimeWindowId[]      // Ej: ["morning", "evening"]
  window_times: {
    morning?: string                  // Ej: "08:00"
    afternoon?: string                // Ej: "14:00"
    evening?: string                  // Ej: "20:00"
  }
  words_per_burst: number             // CALCULADO: ceil(daily_words / bursts_per_day) = 3

  // Paso 6: StepStreakGoal (NO se usa en notificaciones)
  streak_goal_days: number            // Solo para gamificaci√≥n

  // Control
  wizard_completed: boolean           // true cuando completa wizard
}
```

### 1.2. C√≥mo leer estos datos en React Native

```typescript
// En cualquier componente/hook
import { useSelector } from 'react-redux'
import { RootState } from '@/store/store'

const settings = useSelector((state: RootState) => state.settings.data)

// Usar los valores:
const nickname = settings.nickname              // "Mar√≠a"
const categories = settings.categories          // ["technology", "business"]
const activeWindows = settings.active_windows   // ["morning", "evening"]
const windowTimes = settings.window_times       // { morning: "08:00", evening: "20:00" }
const wordsPerBurst = settings.words_per_burst  // 3
```


## 2. ARQUITECTURA DE ARCHIVOS
## =============================

### 2.1. Archivos Android (Kotlin)

```
android/app/src/main/java/com/awesome/
‚îú‚îÄ‚îÄ notifications/
‚îÇ   ‚îú‚îÄ‚îÄ NotificationModule.kt          # Bridge React Native -> Kotlin
‚îÇ   ‚îú‚îÄ‚îÄ NotificationScheduler.kt       # Gesti√≥n de AlarmManager
‚îÇ   ‚îú‚îÄ‚îÄ NotificationReceiver.kt        # Recibe alarmas y muestra notificaciones
‚îÇ   ‚îú‚îÄ‚îÄ NotificationHelper.kt          # Crea las notificaciones visuales
‚îÇ   ‚îú‚îÄ‚îÄ WordsDataStore.kt              # Almacena palabras en SharedPreferences
‚îÇ   ‚îî‚îÄ‚îÄ BootReceiver.kt                # Reprograma al reiniciar dispositivo
‚îî‚îÄ‚îÄ MainApplication.kt                  # Registrar m√≥dulo (MODIFICAR)

android/app/src/main/
‚îî‚îÄ‚îÄ AndroidManifest.xml                 # Permisos y receivers (MODIFICAR)

android/app/
‚îî‚îÄ‚îÄ build.gradle                        # Dependencias Gson (MODIFICAR)
```

### 2.2. Archivos React Native (TypeScript)

```
src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ notificationService.ts         # Bridge tipado para Kotlin
‚îî‚îÄ‚îÄ hooks/
    ‚îî‚îÄ‚îÄ useNotifications.ts            # Hook para programar notificaciones
```


## 3. FASES DE IMPLEMENTACI√ìN
## ===========================

### FASE 1: Configuraci√≥n base Android
### FASE 2: M√≥dulos Kotlin nativos
### FASE 3: Bridge React Native
### FASE 4: Integraci√≥n con Wizard
### FASE 5: Testing y validaci√≥n


## 4. ORDEN DE CREACI√ìN DE ARCHIVOS
## =================================

### FASE 1: CONFIGURACI√ìN BASE ANDROID (3 archivos)

#### Archivo 1.1: android/app/src/main/AndroidManifest.xml
**QU√â HACE:** Declara permisos y receivers
**AGREGAR DENTRO DE `<manifest>`:**

```xml
<!-- Permisos necesarios -->
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
<uses-permission android:name="android.permission.USE_EXACT_ALARM" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS" />
```

**AGREGAR DENTRO DE `<application>`:**

```xml
<!-- Receiver para notificaciones programadas -->
<receiver
    android:name=".notifications.NotificationReceiver"
    android:enabled="true"
    android:exported="false">
    <intent-filter>
        <action android:name="com.vocabox.hermes.SHOW_NOTIFICATION" />
    </intent-filter>
</receiver>

<!-- Receiver para reinicio de dispositivo -->
<receiver
    android:name=".notifications.BootReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter>
        <action android:name="android.intent.action.BOOT_COMPLETED" />
        <action android:name="android.intent.action.QUICKBOOT_POWERON" />
    </intent-filter>
</receiver>
```

---

#### Archivo 1.2: android/app/build.gradle
**QU√â HACE:** Agrega dependencia Gson para JSON
**AGREGAR EN `dependencies {}`:**

```gradle
// Gson para serializaci√≥n JSON de palabras
implementation 'com.google.code.gson:gson:2.10.1'
```

---

#### Archivo 1.3: Crear carpeta notifications
**EJECUTAR EN TERMINAL:**

```bash
mkdir -p android/app/src/main/java/com/awesome/notifications
```

**NOTA:** Cambiar `com/awesome` por el package name de tu app


---

### FASE 2: M√ìDULOS KOTLIN NATIVOS (6 archivos)

#### Archivo 2.1: WordsDataStore.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/WordsDataStore.kt`
**QU√â HACE:** Almacena palabras y configuraci√≥n en SharedPreferences
**DATOS QUE GUARDA:**
- Lista de palabras (word, meaning, category)
- Categor√≠as seleccionadas
- Words per burst
- Nickname

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.Context
import android.content.SharedPreferences
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken

data class WordData(
    val id: String,
    val word: String,
    val meaning: String,
    val category: String
)

class WordsDataStore(context: Context) {

    private val prefs: SharedPreferences = context.getSharedPreferences(
        "words_storage",
        Context.MODE_PRIVATE
    )
    private val gson = Gson()

    fun saveWords(words: List<WordData>) {
        val json = gson.toJson(words)
        prefs.edit().putString("all_words", json).apply()
    }

    fun getAllWords(): List<WordData> {
        val json = prefs.getString("all_words", "[]") ?: "[]"
        val type = object : TypeToken<List<WordData>>() {}.type
        return gson.fromJson(json, type)
    }

    fun getWordsByCategories(categories: List<String>): List<WordData> {
        return getAllWords().filter { word ->
            categories.contains(word.category)
        }
    }

    fun saveCategories(categories: List<String>) {
        val json = gson.toJson(categories)
        prefs.edit().putString("categories", json).apply()
    }

    fun saveWordsPerBurst(count: Int) {
        prefs.edit().putInt("words_per_burst", count).apply()
    }

    fun saveNickname(nickname: String) {
        prefs.edit().putString("nickname", nickname).apply()
    }

    fun getNickname(): String {
        return prefs.getString("nickname", "Usuario") ?: "Usuario"
    }

    fun getWordsPerBurst(): Int {
        return prefs.getInt("words_per_burst", 2)
    }
}
```

---

#### Archivo 2.2: NotificationHelper.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/NotificationHelper.kt`
**QU√â HACE:** Crea las notificaciones visuales con palabra + significado
**DATOS QUE USA:**
- nickname (del wizard)
- word + meaning (de la base de datos)
- window (morning/afternoon/evening)

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import androidx.core.app.NotificationCompat
import com.vocabox.hermes.MainActivity
import com.vocabox.hermes.R

object NotificationHelper {

    private const val CHANNEL_ID = "daily_study_channel"
    private const val CHANNEL_NAME = "Estudio Diario"
    private const val CHANNEL_DESCRIPTION = "Notificaciones para aprender palabras diarias"

    fun createNotificationChannel(context: Context) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel(CHANNEL_ID, CHANNEL_NAME, importance).apply {
                description = CHANNEL_DESCRIPTION
                enableLights(true)
                enableVibration(true)
            }

            val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE)
                as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    fun showNotification(
        context: Context,
        notificationId: Int,
        window: String,
        nickname: String,
        word: String,
        meaning: String,
        allWords: List<WordData>
    ) {
        createNotificationChannel(context)

        val intent = Intent(context, MainActivity::class.java).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            putExtra("notification_data", true)
            putExtra("window", window)
            putExtra("words_json", wordsToJson(allWords))
        }

        val pendingIntent = PendingIntent.getActivity(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // T√≠tulo personalizado seg√∫n ventana
        val title = when (window) {
            "morning" -> "¬°Buenos d√≠as, $nickname! üåÖ"
            "afternoon" -> "¬°Buenas tardes, $nickname! ‚òÄÔ∏è"
            "evening" -> "¬°Buenas noches, $nickname! üåô"
            else -> "¬°Hola, $nickname! üëã"
        }

        // Cuerpo: palabra = significado
        val body = "üìö $word = $meaning"

        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle(title)
            .setContentText(body)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setCategory(NotificationCompat.CATEGORY_REMINDER)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .build()

        val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE)
            as NotificationManager
        notificationManager.notify(notificationId, notification)
    }

    private fun wordsToJson(words: List<WordData>): String {
        return words.joinToString(separator = ",", prefix = "[", postfix = "]") { word ->
            """{"id":"${word.id}","word":"${word.word}","meaning":"${word.meaning}","category":"${word.category}"}"""
        }
    }
}
```

**NOTA:** Debes crear el √≠cono `ic_notification.xml` en `android/app/src/main/res/drawable/`

---

#### Archivo 2.3: NotificationScheduler.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/NotificationScheduler.kt`
**QU√â HACE:** Programa alarmas exactas con AlarmManager
**DATOS QUE USA:**
- active_windows (del wizard)
- window_times (del wizard: "08:00", "14:00", "20:00")
- categories (del wizard)
- words_per_burst (calculado en wizard)
- nickname (del wizard)

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import java.util.*

class NotificationScheduler(private val context: Context) {

    private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    private val TAG = "NotificationScheduler"

    fun scheduleExactAlarm(
        notificationId: Int,
        window: String,
        hour: Int,
        minute: Int,
        categories: List<String>,
        wordsPerBurst: Int,
        nickname: String
    ) {
        val calendar = Calendar.getInstance().apply {
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)

            // Si la hora ya pas√≥ hoy, programar para ma√±ana
            if (timeInMillis <= System.currentTimeMillis()) {
                add(Calendar.DAY_OF_YEAR, 1)
            }
        }

        val intent = Intent(context, NotificationReceiver::class.java).apply {
            action = "com.vocabox.hermes.SHOW_NOTIFICATION"
            putExtra("notification_id", notificationId)
            putExtra("window", window)
            putExtra("hour", hour)
            putExtra("minute", minute)
            putExtra("categories", categories.toTypedArray())
            putExtra("words_per_burst", wordsPerBurst)
            putExtra("nickname", nickname)
        }

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        // setExactAndAllowWhileIdle ignora Doze mode y optimizaci√≥n de bater√≠a
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        }

        Log.d(TAG, "Scheduled exact alarm for $window at $hour:$minute (ID: $notificationId)")
    }

    fun cancelAllNotifications() {
        val windows = listOf("morning", "afternoon", "evening")

        windows.forEach { window ->
            val notificationId = window.hashCode()
            val intent = Intent(context, NotificationReceiver::class.java)
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                notificationId,
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            alarmManager.cancel(pendingIntent)
            pendingIntent.cancel()
            Log.d(TAG, "Cancelled alarm for $window (ID: $notificationId)")
        }
    }
}
```

---

#### Archivo 2.4: NotificationReceiver.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/NotificationReceiver.kt`
**QU√â HACE:** Recibe la alarma, selecciona palabras y muestra notificaci√≥n
**FLUJO:**
1. Recibe alarma de AlarmManager
2. Lee palabras de SharedPreferences filtradas por categories
3. Selecciona N palabras aleatorias (words_per_burst)
4. Muestra notificaci√≥n con primera palabra
5. Reprograma alarma para ma√±ana

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.app.AlarmManager
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.os.Build
import android.util.Log
import java.util.*

class NotificationReceiver : BroadcastReceiver() {

    private val TAG = "NotificationReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        Log.d(TAG, "onReceive triggered: ${intent.action}")

        when (intent.action) {
            "com.vocabox.hermes.SHOW_NOTIFICATION" -> {
                handleShowNotification(context, intent)
            }
        }
    }

    private fun handleShowNotification(context: Context, intent: Intent) {
        val notificationId = intent.getIntExtra("notification_id", 0)
        val window = intent.getStringExtra("window") ?: "morning"
        val hour = intent.getIntExtra("hour", 8)
        val minute = intent.getIntExtra("minute", 0)
        val categories = intent.getStringArrayExtra("categories")?.toList() ?: emptyList()
        val wordsPerBurst = intent.getIntExtra("words_per_burst", 2)
        val nickname = intent.getStringExtra("nickname") ?: "Usuario"

        Log.d(TAG, "Showing notification for window: $window at $hour:$minute")

        // Obtener palabras del almacenamiento local
        val wordsStore = WordsDataStore(context)
        val availableWords = wordsStore.getWordsByCategories(categories)

        // Seleccionar palabras aleatorias
        val selectedWords = availableWords
            .shuffled()
            .take(wordsPerBurst)

        if (selectedWords.isEmpty()) {
            Log.w(TAG, "No words available for categories: $categories")
            NotificationHelper.showNotification(
                context = context,
                notificationId = notificationId,
                window = window,
                nickname = nickname,
                word = "vocabulary",
                meaning = "vocabulario",
                allWords = emptyList()
            )
        } else {
            val firstWord = selectedWords[0]
            NotificationHelper.showNotification(
                context = context,
                notificationId = notificationId,
                window = window,
                nickname = nickname,
                word = firstWord.word,
                meaning = firstWord.meaning,
                allWords = selectedWords
            )
        }

        // RE-PROGRAMAR la alarma para ma√±ana
        reprogramAlarmForTomorrow(context, intent, notificationId, hour, minute)
    }

    private fun reprogramAlarmForTomorrow(
        context: Context,
        originalIntent: Intent,
        notificationId: Int,
        hour: Int,
        minute: Int
    ) {
        val calendar = Calendar.getInstance().apply {
            add(Calendar.DAY_OF_YEAR, 1)
            set(Calendar.HOUR_OF_DAY, hour)
            set(Calendar.MINUTE, minute)
            set(Calendar.SECOND, 0)
            set(Calendar.MILLISECOND, 0)
        }

        val newIntent = Intent(originalIntent)

        val pendingIntent = PendingIntent.getBroadcast(
            context,
            notificationId,
            newIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        } else {
            alarmManager.setExact(
                AlarmManager.RTC_WAKEUP,
                calendar.timeInMillis,
                pendingIntent
            )
        }

        Log.d(TAG, "Rescheduled alarm for tomorrow at $hour:$minute")
    }
}
```

---

#### Archivo 2.5: BootReceiver.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/BootReceiver.kt`
**QU√â HACE:** Reprograma alarmas cuando el dispositivo se reinicia
**PENDIENTE:** Requiere leer configuraci√≥n guardada y reprogramar

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log

class BootReceiver : BroadcastReceiver() {

    private val TAG = "BootReceiver"

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED ||
            intent.action == "android.intent.action.QUICKBOOT_POWERON") {

            Log.d(TAG, "Device booted, rescheduling notifications")

            // TODO: Leer configuraci√≥n guardada y reprogramar alarmas
            // Esto se implementar√° en una fase posterior
        }
    }
}
```

---

#### Archivo 2.6: NotificationModule.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/notifications/NotificationModule.kt`
**QU√â HACE:** Bridge entre React Native y Kotlin
**M√âTODOS EXPUESTOS A JS:**
- scheduleNotifications(settings)
- cancelAllNotifications()
- saveWords(words)
- requestIgnoreBatteryOptimization()
- checkExactAlarmPermission()
- requestExactAlarmPermission()

**DATOS QUE RECIBE DE REACT NATIVE:**
```javascript
settings = {
  categories: ["technology", "business"],
  active_windows: ["morning", "evening"],
  window_times: { morning: "08:00", evening: "20:00" },
  words_per_burst: 3,
  nickname: "Mar√≠a"
}
```

**CREAR ARCHIVO:**

```kotlin
package com.vocabox.hermes.notifications

import android.content.Intent
import android.net.Uri
import android.os.Build
import android.provider.Settings
import com.facebook.react.bridge.*

class NotificationModule(reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    private val scheduler = NotificationScheduler(reactContext)
    private val wordsStore = WordsDataStore(reactContext)

    override fun getName(): String = "NotificationModule"

    @ReactMethod
    fun scheduleNotifications(settings: ReadableMap, promise: Promise) {
        try {
            scheduler.cancelAllNotifications()

            val categories = settings.getArray("categories")?.toArrayList() as? List<String>
                ?: emptyList()
            val activeWindows = settings.getArray("active_windows")?.toArrayList() as? List<String>
                ?: emptyList()
            val windowTimes = settings.getMap("window_times")
            val wordsPerBurst = settings.getInt("words_per_burst")
            val nickname = settings.getString("nickname") ?: "Usuario"

            wordsStore.saveCategories(categories)
            wordsStore.saveWordsPerBurst(wordsPerBurst)
            wordsStore.saveNickname(nickname)

            var scheduledCount = 0
            activeWindows.forEach { window ->
                val timeStr = windowTimes?.getString(window)
                if (timeStr != null) {
                    val (hour, minute) = timeStr.split(":").map { it.toInt() }
                    val notificationId = window.hashCode()

                    scheduler.scheduleExactAlarm(
                        notificationId = notificationId,
                        window = window,
                        hour = hour,
                        minute = minute,
                        categories = categories,
                        wordsPerBurst = wordsPerBurst,
                        nickname = nickname
                    )

                    scheduledCount++
                }
            }

            promise.resolve("Scheduled $scheduledCount notifications")
        } catch (e: Exception) {
            promise.reject("SCHEDULE_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun cancelAllNotifications(promise: Promise) {
        try {
            scheduler.cancelAllNotifications()
            promise.resolve("All notifications cancelled")
        } catch (e: Exception) {
            promise.reject("CANCEL_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun requestIgnoreBatteryOptimization(promise: Promise) {
        try {
            val activity = currentActivity
            if (activity == null) {
                promise.reject("NO_ACTIVITY", "Activity not available")
                return
            }

            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                val packageName = reactApplicationContext.packageName
                val intent = Intent().apply {
                    action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
                    data = Uri.parse("package:$packageName")
                }
                activity.startActivity(intent)
                promise.resolve("Battery optimization dialog opened")
            } else {
                promise.resolve("Not needed for this Android version")
            }
        } catch (e: Exception) {
            promise.reject("BATTERY_OPT_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun checkExactAlarmPermission(promise: Promise) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val alarmManager = reactApplicationContext
                    .getSystemService(android.content.Context.ALARM_SERVICE) as android.app.AlarmManager
                val canSchedule = alarmManager.canScheduleExactAlarms()
                promise.resolve(canSchedule)
            } else {
                promise.resolve(true)
            }
        } catch (e: Exception) {
            promise.reject("PERMISSION_CHECK_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun requestExactAlarmPermission(promise: Promise) {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM)
                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
                reactApplicationContext.startActivity(intent)
                promise.resolve("Permission dialog opened")
            } else {
                promise.resolve("Not needed for this Android version")
            }
        } catch (e: Exception) {
            promise.reject("PERMISSION_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun saveWords(wordsArray: ReadableArray, promise: Promise) {
        try {
            val words = mutableListOf<WordData>()
            for (i in 0 until wordsArray.size()) {
                val wordMap = wordsArray.getMap(i)
                if (wordMap != null) {
                    words.add(WordData(
                        id = wordMap.getString("id") ?: "",
                        word = wordMap.getString("word") ?: "",
                        meaning = wordMap.getString("meaning") ?: "",
                        category = wordMap.getString("category") ?: ""
                    ))
                }
            }
            wordsStore.saveWords(words)
            promise.resolve("Saved ${words.size} words")
        } catch (e: Exception) {
            promise.reject("SAVE_WORDS_ERROR", e.message, e)
        }
    }
}
```

---

### FASE 3: REGISTRAR M√ìDULO EN REACT NATIVE

#### Archivo 3.1: MainApplication.kt
**UBICACI√ìN:** `android/app/src/main/java/com/awesome/MainApplication.kt`
**QU√â HACE:** Registra NotificationModule para que React Native lo reconozca
**MODIFICAR:**

```kotlin
package com.vocabox.hermes

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.soloader.SoLoader
import com.vocabox.hermes.notifications.NotificationModule      // AGREGAR
import com.vocabox.hermes.notifications.NotificationHelper     // AGREGAR
import com.facebook.react.bridge.ReactApplicationContext // AGREGAR

class MainApplication : Application(), ReactApplication {

    override val reactNativeHost: ReactNativeHost =
        object : DefaultReactNativeHost(this) {
            override fun getPackages(): List<ReactPackage> =
                PackageList(this).packages.apply {
                    // AGREGAR el paquete de notificaciones
                    add(object : ReactPackage {
                        override fun createNativeModules(reactContext: ReactApplicationContext) =
                            listOf(NotificationModule(reactContext))

                        override fun createViewManagers(reactContext: ReactApplicationContext) =
                            emptyList<com.facebook.react.uimanager.ViewManager<*, *>>()
                    })
                }

            override fun getJSMainModuleName(): String = "index"
            override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG
            override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
            override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED
        }

    override val reactHost: ReactHost
        get() = getDefaultReactHost(applicationContext, reactNativeHost)

    override fun onCreate() {
        super.onCreate()
        SoLoader.init(this, false)
        if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
            load()
        }

        // AGREGAR: Crear canal de notificaciones
        NotificationHelper.createNotificationChannel(this)
    }
}
```

---

### FASE 4: BRIDGE REACT NATIVE (TYPESCRIPT)

#### Archivo 4.1: src/services/notificationService.ts
**QU√â HACE:** Tipado TypeScript del m√≥dulo nativo
**CREAR ARCHIVO:**

```typescript
import { NativeModules } from 'react-native'

interface NotificationModuleInterface {
  scheduleNotifications(settings: {
    categories: string[]
    active_windows: string[]
    window_times: {
      morning?: string
      afternoon?: string
      evening?: string
    }
    words_per_burst: number
    nickname: string
  }): Promise<string>

  cancelAllNotifications(): Promise<string>
  requestIgnoreBatteryOptimization(): Promise<string>
  checkExactAlarmPermission(): Promise<boolean>
  requestExactAlarmPermission(): Promise<string>
  saveWords(words: Array<{
    id: string
    word: string
    meaning: string
    category: string
  }>): Promise<string>
}

const { NotificationModule } = NativeModules
export default NotificationModule as NotificationModuleInterface
```

---

#### Archivo 4.2: src/hooks/useNotifications.ts
**QU√â HACE:** Hook para programar notificaciones desde React Native
**DATOS QUE LEE:** Todos los del wizard desde Redux
**CREAR ARCHIVO:**

```typescript
import { useEffect } from 'react'
import { useSelector } from 'react-redux'
import { RootState } from '@/store/store'
import NotificationModule from '@/services/notificationService'
import { supabase } from '@/services/supebase'

export function useNotifications() {
  const settings = useSelector((state: RootState) => state.settings.data)
  const wizardCompleted = settings.wizard_completed

  useEffect(() => {
    if (wizardCompleted) {
      setupNotifications()
    }
  }, [wizardCompleted])

  const setupNotifications = async () => {
    try {
      console.log('Setting up notifications with settings:', settings)

      // 1. Verificar permisos de alarmas exactas (Android 12+)
      const canSchedule = await NotificationModule.checkExactAlarmPermission()
      if (!canSchedule) {
        console.log('Requesting exact alarm permission...')
        await NotificationModule.requestExactAlarmPermission()
        return
      }

      // 2. Solicitar ignorar optimizaci√≥n de bater√≠a
      await NotificationModule.requestIgnoreBatteryOptimization()

      // 3. Obtener palabras de Supabase filtradas por categor√≠as
      const { data: words, error } = await supabase
        .from('words')
        .select('*')
        .in('category', settings.categories || [])
        .limit(100)

      if (error) {
        console.error('Error fetching words:', error)
        return
      }

      // 4. Guardar palabras en almacenamiento nativo
      if (words && words.length > 0) {
        await NotificationModule.saveWords(words)
        console.log(`Saved ${words.length} words to native storage`)
      }

      // 5. Programar notificaciones con configuraci√≥n del wizard
      const result = await NotificationModule.scheduleNotifications({
        categories: settings.categories || [],
        active_windows: settings.active_windows || ['morning'],
        window_times: settings.window_times || { morning: '08:00' },
        words_per_burst: settings.words_per_burst || 2,
        nickname: settings.nickname || 'Usuario'
      })

      console.log('Notifications scheduled:', result)
    } catch (error) {
      console.error('Error setting up notifications:', error)
    }
  }

  return {
    setupNotifications
  }
}
```

---

### FASE 5: INTEGRACI√ìN CON WIZARD

#### Archivo 5.1: Llamar setupNotifications al completar wizard
**UBICACI√ìN:** `src/viewmodels/useWizardViewModel.ts`
**MODIFICAR la funci√≥n `saveAndComplete`:**

```typescript
import { useNotifications } from '@/hooks/useNotifications'

export const useWizardViewModel = () => {
  // ... c√≥digo existente

  const { setupNotifications } = useNotifications()

  const saveAndComplete = useCallback(async () => {
    const currentUser = userRef.current
    const currentData = dataRef.current

    if (!currentUser) {
      console.log('No user found')
      return false
    }

    try {
      dispatch(wizardSaveStart())

      const settingsToSave = {
        ...currentData,
        user_id: currentUser.id,
        wizard_completed: true
      }

      console.log('Saving settings:', JSON.stringify(settingsToSave, null, 2))

      const result = await upsertSettings(settingsToSave as any)
      console.log('Settings saved successfully:', result)

      dispatch(completeWizard())
      dispatch(wizardSaveSuccess(result))

      // AGREGAR: Programar notificaciones
      await setupNotifications()

      navigation.dispatch(
        CommonActions.reset({
          index: 0,
          routes: [{ name: 'Main' }],
        })
      )

      return true
    } catch (error) {
      // ... manejo de errores existente
    }
  }, [dispatch, navigation, setupNotifications])

  // ... resto del c√≥digo
}
```

---

## 5. FLUJO DE DATOS COMPLETO
## ===========================

### Paso 1: Usuario completa el Wizard
```
StepNameMotivation ‚Üí nickname: "Mar√≠a"
StepCategories ‚Üí categories: ["technology", "business"]
StepWeeklyTarget ‚Üí weekly_words_target: 30 ‚Üí daily_words: 5
StepBurstsAndTimes ‚Üí bursts_per_day: 2, active_windows: ["morning", "evening"]
                   ‚Üí window_times: { morning: "08:00", evening: "20:00" }
                   ‚Üí words_per_burst: 3
```

### Paso 2: Datos se guardan en Redux
```
Redux Store (state.settings.data)
‚îú‚îÄ‚îÄ nickname: "Mar√≠a"
‚îú‚îÄ‚îÄ categories: ["technology", "business"]
‚îú‚îÄ‚îÄ weekly_words_target: 30
‚îú‚îÄ‚îÄ daily_words: 5
‚îú‚îÄ‚îÄ bursts_per_day: 2
‚îú‚îÄ‚îÄ active_windows: ["morning", "evening"]
‚îú‚îÄ‚îÄ window_times: { morning: "08:00", evening: "20:00" }
‚îú‚îÄ‚îÄ words_per_burst: 3
‚îî‚îÄ‚îÄ wizard_completed: true
```

### Paso 3: Guardar en Supabase
```
upsertSettings(settings) ‚Üí tabla user_settings
```

### Paso 4: useNotifications() se ejecuta autom√°ticamente
```typescript
// Detecta wizard_completed === true
useEffect(() => {
  if (wizardCompleted) {
    setupNotifications()
  }
}, [wizardCompleted])
```

### Paso 5: setupNotifications() ejecuta
```
1. Verificar permisos ‚Üí checkExactAlarmPermission()
2. Solicitar bater√≠a ‚Üí requestIgnoreBatteryOptimization()
3. Obtener palabras de Supabase filtradas por categories
4. Guardar palabras en Kotlin ‚Üí saveWords(words)
5. Programar notificaciones ‚Üí scheduleNotifications({
     categories: ["technology", "business"],
     active_windows: ["morning", "evening"],
     window_times: { morning: "08:00", evening: "20:00" },
     words_per_burst: 3,
     nickname: "Mar√≠a"
   })
```

### Paso 6: NotificationModule.kt recibe datos
```kotlin
scheduleNotifications(settings) {
  // Cancelar notificaciones anteriores
  // Para cada ventana activa:
  //   - Programar alarma exacta con AlarmManager
  //   - ID √∫nico por ventana
  //   - Guardar configuraci√≥n en SharedPreferences
}
```

### Paso 7: AlarmManager programa alarmas
```
Alarma 1: ID = "morning".hashCode()
  - Hora: 08:00 AM
  - Datos: categories, words_per_burst, nickname

Alarma 2: ID = "evening".hashCode()
  - Hora: 20:00 PM (8:00 PM)
  - Datos: categories, words_per_burst, nickname
```

### Paso 8: A las 08:00 AM, AlarmManager dispara NotificationReceiver
```kotlin
NotificationReceiver.onReceive() {
  1. Lee palabras de SharedPreferences
  2. Filtra por categories: ["technology", "business"]
  3. Selecciona 3 palabras aleatorias (words_per_burst)
  4. Toma la primera palabra: { word: "achievement", meaning: "logro" }
  5. Muestra notificaci√≥n:
     T√≠tulo: "¬°Buenos d√≠as, Mar√≠a! üåÖ"
     Cuerpo: "üìö achievement = logro"
  6. Reprograma alarma para ma√±ana a las 08:00 AM
}
```

### Paso 9: Usuario toca la notificaci√≥n
```
Intent abre MainActivity con extras:
- notification_data: true
- window: "morning"
- words_json: [{"word":"achievement","meaning":"logro"}, ...]

React Native puede leer estos datos y navegar a pantalla de estudio
```

---

## 6. RESUMEN DE IMPLEMENTACI√ìN
## =============================

### Archivos a crear (total: 11)

**Android Kotlin (6 archivos):**
1. ‚úÖ WordsDataStore.kt
2. ‚úÖ NotificationHelper.kt
3. ‚úÖ NotificationScheduler.kt
4. ‚úÖ NotificationReceiver.kt
5. ‚úÖ BootReceiver.kt
6. ‚úÖ NotificationModule.kt

**Android modificar (3 archivos):**
7. ‚úÖ AndroidManifest.xml
8. ‚úÖ build.gradle
9. ‚úÖ MainApplication.kt

**React Native TypeScript (2 archivos):**
10. ‚úÖ src/services/notificationService.ts
11. ‚úÖ src/hooks/useNotifications.ts

**React Native modificar (1 archivo):**
12. ‚úÖ src/viewmodels/useWizardViewModel.ts

### Caracter√≠sticas finales:
- ‚úÖ Notificaciones EXACTAS con AlarmManager
- ‚úÖ Funciona con app cerrada/muerta
- ‚úÖ Ignora optimizaci√≥n de bater√≠a y Doze mode
- ‚úÖ Muestra palabra + significado
- ‚úÖ Filtra por categor√≠as del wizard
- ‚úÖ Usa nickname del wizard
- ‚úÖ Respeta horarios del wizard
- ‚úÖ Se reprograma autom√°ticamente cada d√≠a
- ‚úÖ Persiste al reiniciar dispositivo

### Datos del wizard utilizados:
1. ‚úÖ nickname ‚Üí T√≠tulo de notificaci√≥n
2. ‚úÖ categories ‚Üí Filtrar palabras
3. ‚úÖ active_windows ‚Üí Cu√°ntas notificaciones/d√≠a
4. ‚úÖ window_times ‚Üí Horarios exactos
5. ‚úÖ words_per_burst ‚Üí Cu√°ntas palabras mostrar

---

## 7. CASOS DE USO PARA PRUEBAS
## ================================

### 7.1. VERIFICACI√ìN ACTUAL DEL C√ìDIGO

#### ‚úÖ S√ç filtra por categor√≠as seleccionadas
**Ubicaci√≥n:** `NotificationReceiver.kt:39`
```kotlin
val availableWords = wordsStore.getWordsByCategories(categories)
```
- Las categor√≠as vienen del wizard
- Solo muestra palabras de esas categor√≠as
- Si no hay palabras, muestra "vocabulary = vocabulario" por defecto

#### ‚úÖ S√ç respeta horarios configurados
**Ubicaci√≥n:** `NotificationScheduler.kt:25-35`
```kotlin
val calendar = Calendar.getInstance().apply {
    set(Calendar.HOUR_OF_DAY, hour)  // Hora del wizard
    set(Calendar.MINUTE, minute)      // Minuto del wizard
}
```

#### ‚úÖ S√ç selecciona m√∫ltiples palabras por notificaci√≥n
**Ubicaci√≥n:** `NotificationReceiver.kt:42-44`
```kotlin
val selectedWords = availableWords
    .shuffled()
    .take(wordsPerBurst)  // Cantidad del wizard
```
- Actualmente solo muestra la primera palabra en la notificaci√≥n
- Las dem√°s se env√≠an al Intent para uso en la app

#### ‚úÖ S√ç se reprograma autom√°ticamente
**Ubicaci√≥n:** `NotificationReceiver.kt:71 y 81-87`
```kotlin
reprogramAlarmForTomorrow() {
    add(Calendar.DAY_OF_YEAR, 1)  // Ma√±ana mismo horario
}
```

---

### 7.2. C√ìMO AFECTA CADA CONFIGURACI√ìN DEL WIZARD

#### PASO 2: StepNameMotivation
**Campo:** `nickname`
**Valor ejemplo:** "Mar√≠a"
**Impacto en notificaciones:**
- ‚úÖ Aparece en el t√≠tulo de la notificaci√≥n
- T√≠tulo morning: "¬°Buenos d√≠as, Mar√≠a! üåÖ"
- T√≠tulo afternoon: "¬°Buenas tardes, Mar√≠a! ‚òÄÔ∏è"
- T√≠tulo evening: "¬°Buenas noches, Mar√≠a! üåô"

**C√≥digo:** `NotificationHelper.kt:334-339`

---

#### PASO 3: StepCategories
**Campo:** `categories`
**Valor ejemplo:** `["technology", "business", "science"]`
**Impacto en notificaciones:**
- ‚úÖ Filtra palabras SOLO de esas categor√≠as
- ‚úÖ Si seleccionas 3 categor√≠as, todas las palabras mostradas ser√°n de esas 3
- ‚ö†Ô∏è Si no hay palabras en esas categor√≠as, muestra "vocabulary = vocabulario"

**C√≥digo:** `NotificationReceiver.kt:31 y 39`
```kotlin
val categories = intent.getStringArrayExtra("categories")?.toList() ?: emptyList()
val availableWords = wordsStore.getWordsByCategories(categories)
```

**Prueba:**
1. Selecciona SOLO "technology" en el wizard
2. Completa wizard
3. Verifica que todas las notificaciones sean palabras de tecnolog√≠a

---

#### PASO 4: StepWeeklyTarget
**Campo:** `weekly_words_target`
**Valor ejemplo:** 30 palabras/semana
**C√°lculo autom√°tico:** `daily_words = ceil(30/7) = 5`
**Impacto en notificaciones:**
- ‚ùå NO afecta directamente las notificaciones
- ‚úÖ Se usa solo para calcular `words_per_burst`

---

#### PASO 5: StepBurstsAndTimes
**Campo 1:** `bursts_per_day`
**Valor ejemplo:** 2 (dos veces al d√≠a)
**Impacto:**
- ‚úÖ Determina CU√ÅNTAS notificaciones recibir√°s al d√≠a
- Si seleccionas 1 ‚Üí 1 notificaci√≥n/d√≠a
- Si seleccionas 2 ‚Üí 2 notificaciones/d√≠a
- Si seleccionas 3 ‚Üí 3 notificaciones/d√≠a

**C√≥digo:** `NotificationModule.kt:46-64`
```kotlin
activeWindows.forEach { window ->
    // Programa UNA alarma por cada ventana activa
}
```

**Prueba:**
- `bursts_per_day: 1` + `active_windows: ["morning"]` = 1 notificaci√≥n a las 08:00
- `bursts_per_day: 2` + `active_windows: ["morning", "evening"]` = 2 notificaciones
- `bursts_per_day: 3` + `active_windows: ["morning", "afternoon", "evening"]` = 3 notificaciones

---

**Campo 2:** `active_windows`
**Valor ejemplo:** `["morning", "evening"]`
**Impacto:**
- ‚úÖ Define EN QU√â MOMENTOS del d√≠a recibes notificaciones
- morning ‚Üí ma√±ana
- afternoon ‚Üí tarde
- evening ‚Üí noche

**C√≥digo:** `NotificationModule.kt:46`

---

**Campo 3:** `window_times`
**Valor ejemplo:** `{ morning: "08:00", evening: "20:00" }`
**Impacto:**
- ‚úÖ Define LA HORA EXACTA de cada notificaci√≥n
- "08:00" ‚Üí 8:00 AM
- "20:00" ‚Üí 8:00 PM (20:00 en formato 24h)

**C√≥digo:** `NotificationScheduler.kt:26-27`

**Prueba:**
1. Configura: `window_times: { morning: "09:30" }`
2. La notificaci√≥n llegar√° EXACTAMENTE a las 9:30 AM
3. Si la hora ya pas√≥ hoy, se programa para ma√±ana

---

**Campo 4:** `words_per_burst`
**C√°lculo:** `ceil(daily_words / bursts_per_day)`
**Ejemplo:**
- `daily_words: 5` + `bursts_per_day: 2` = `words_per_burst: 3`
- `daily_words: 6` + `bursts_per_day: 3` = `words_per_burst: 2`

**Impacto:**
- ‚úÖ Cu√°ntas palabras se seleccionan aleatoriamente
- ‚ö†Ô∏è ACTUALMENTE solo muestra la primera palabra en la notificaci√≥n
- ‚úÖ Las dem√°s se env√≠an al Intent para mostrar en la app

**C√≥digo:** `NotificationReceiver.kt:42-44`
```kotlin
val selectedWords = availableWords
    .shuffled()           // Mezcla todas las palabras
    .take(wordsPerBurst)  // Toma N palabras (ej: 3)

// Pero solo muestra la primera en la notificaci√≥n
val firstWord = selectedWords[0]
```

---

### 7.3. CASOS DE USO PARA PRUEBAS

#### CASO 1: Configuraci√≥n B√°sica (1 notificaci√≥n diaria)
**Configuraci√≥n del Wizard:**
```javascript
{
  nickname: "Juan",
  categories: ["technology"],
  weekly_words_target: 10,
  bursts_per_day: 1,
  active_windows: ["morning"],
  window_times: { morning: "09:00" }
}
```

**Resultado esperado:**
- ‚úÖ 1 notificaci√≥n al d√≠a
- ‚úÖ A las 9:00 AM exactamente
- ‚úÖ T√≠tulo: "¬°Buenos d√≠as, Juan! üåÖ"
- ‚úÖ Cuerpo: "üìö [palabra de technology] = [significado]"
- ‚úÖ Palabras SOLO de categor√≠a "technology"
- ‚úÖ Se repite todos los d√≠as a las 9:00 AM

**C√°lculos:**
- `daily_words = ceil(10/7) = 2`
- `words_per_burst = ceil(2/1) = 2`
- Se seleccionan 2 palabras, se muestra 1 en notificaci√≥n

---

#### CASO 2: Configuraci√≥n Moderada (2 notificaciones diarias)
**Configuraci√≥n del Wizard:**
```javascript
{
  nickname: "Ana",
  categories: ["business", "science"],
  weekly_words_target: 30,
  bursts_per_day: 2,
  active_windows: ["morning", "evening"],
  window_times: {
    morning: "08:00",
    evening: "19:00"
  }
}
```

**Resultado esperado:**
- ‚úÖ 2 notificaciones al d√≠a
- ‚úÖ Primera a las 8:00 AM
  - T√≠tulo: "¬°Buenos d√≠as, Ana! üåÖ"
  - Palabras de "business" o "science" (aleatorio)
- ‚úÖ Segunda a las 19:00 (7:00 PM)
  - T√≠tulo: "¬°Buenas noches, Ana! üåô"
  - Palabras de "business" o "science" (aleatorio)
- ‚úÖ Diferentes palabras en cada notificaci√≥n (shuffled)

**C√°lculos:**
- `daily_words = ceil(30/7) = 5`
- `words_per_burst = ceil(5/2) = 3`
- Se seleccionan 3 palabras por notificaci√≥n, se muestra 1

---

#### CASO 3: Configuraci√≥n Intensiva (3 notificaciones diarias)
**Configuraci√≥n del Wizard:**
```javascript
{
  nickname: "Carlos",
  categories: ["technology", "business", "science", "arts"],
  weekly_words_target: 50,
  bursts_per_day: 3,
  active_windows: ["morning", "afternoon", "evening"],
  window_times: {
    morning: "07:00",
    afternoon: "13:00",
    evening: "20:30"
  }
}
```

**Resultado esperado:**
- ‚úÖ 3 notificaciones al d√≠a
- ‚úÖ 7:00 AM ‚Üí "¬°Buenos d√≠as, Carlos! üåÖ"
- ‚úÖ 13:00 (1:00 PM) ‚Üí "¬°Buenas tardes, Carlos! ‚òÄÔ∏è"
- ‚úÖ 20:30 (8:30 PM) ‚Üí "¬°Buenas noches, Carlos! üåô"
- ‚úÖ Palabras de 4 categor√≠as mezcladas
- ‚úÖ Mayor variedad de palabras

**C√°lculos:**
- `daily_words = ceil(50/7) = 8`
- `words_per_burst = ceil(8/3) = 3`
- Se seleccionan 3 palabras por notificaci√≥n

---

#### CASO 4: Prueba de Filtrado de Categor√≠as
**Objetivo:** Verificar que SOLO muestra palabras de las categor√≠as seleccionadas

**Pasos:**
1. Completa wizard con SOLO 1 categor√≠a: `["technology"]`
2. Aseg√∫rate de tener palabras en Supabase de esa categor√≠a
3. Espera la notificaci√≥n
4. Verifica que la palabra mostrada sea de "technology"
5. Repite varias veces para confirmar

**C√≥digo responsable:**
```kotlin
// NotificationReceiver.kt:39
val availableWords = wordsStore.getWordsByCategories(categories)
```

---

#### CASO 5: Prueba de Horarios Exactos
**Objetivo:** Verificar que las notificaciones llegan a la hora exacta

**Pasos:**
1. Configura: `window_times: { morning: "14:35" }` (hora 5 minutos en el futuro)
2. Completa wizard
3. Espera hasta las 14:35
4. La notificaci√≥n debe llegar EXACTAMENTE a esa hora (¬±1 minuto por sistema)

**Nota:** Si la hora ya pas√≥, se programa para ma√±ana
```kotlin
// NotificationScheduler.kt:32-34
if (timeInMillis <= System.currentTimeMillis()) {
    add(Calendar.DAY_OF_YEAR, 1)
}
```

---

#### CASO 6: Prueba de Reprogramaci√≥n Autom√°tica
**Objetivo:** Verificar que se reprograma cada d√≠a

**Pasos:**
1. Configura notificaci√≥n para ma√±ana
2. Espera a que llegue la notificaci√≥n
3. Verifica en los logs de Logcat:
```
NotificationReceiver: Rescheduled alarm for tomorrow at HH:mm
```
4. Confirma que al d√≠a siguiente llega de nuevo

**C√≥digo responsable:**
```kotlin
// NotificationReceiver.kt:74-115
reprogramAlarmForTomorrow()
```

---

#### CASO 7: Prueba sin Palabras en Categor√≠as
**Objetivo:** Verificar fallback cuando no hay palabras

**Pasos:**
1. Configura categor√≠as que NO existen en Supabase: `["fake_category"]`
2. Completa wizard
3. Espera notificaci√≥n
4. Debe mostrar: "üìö vocabulary = vocabulario"

**C√≥digo responsable:**
```kotlin
// NotificationReceiver.kt:46-56
if (selectedWords.isEmpty()) {
    NotificationHelper.showNotification(
        word = "vocabulary",
        meaning = "vocabulario"
    )
}
```

---

### 7.4. TABLA RESUMEN: CONFIGURACI√ìN ‚Üí COMPORTAMIENTO

| Configuraci√≥n | Valor Ejemplo | Impacto en Notificaciones |
|---------------|---------------|---------------------------|
| `nickname` | "Mar√≠a" | Personaliza t√≠tulo: "¬°Buenos d√≠as, Mar√≠a! üåÖ" |
| `categories` | ["technology", "science"] | Filtra palabras SOLO de esas categor√≠as |
| `weekly_words_target` | 30 | NO afecta directamente, solo calcula daily_words |
| `daily_words` | 5 | NO afecta directamente, solo calcula words_per_burst |
| `bursts_per_day` | 2 | Define CANTIDAD de notificaciones al d√≠a (1, 2 o 3) |
| `active_windows` | ["morning", "evening"] | Define CU√ÅNDO llegan (ma√±ana, tarde, noche) |
| `window_times.morning` | "08:00" | Hora EXACTA de notificaci√≥n de ma√±ana |
| `window_times.afternoon` | "14:00" | Hora EXACTA de notificaci√≥n de tarde |
| `window_times.evening` | "20:00" | Hora EXACTA de notificaci√≥n de noche |
| `words_per_burst` | 3 | Cu√°ntas palabras se seleccionan (se muestra 1) |

---

### 7.5. TABLA DE HORARIOS POR VENTANA

| Ventana | Emoji | Saludo | Horarios Disponibles | Formato |
|---------|-------|--------|----------------------|---------|
| `morning` | üåÖ | "¬°Buenos d√≠as, {nickname}!" | 06:00 - 11:00 (6am - 11am) | 24h |
| `afternoon` | ‚òÄÔ∏è | "¬°Buenas tardes, {nickname}!" | 12:00 - 18:00 (12pm - 6pm) | 24h |
| `evening` | üåô | "¬°Buenas noches, {nickname}!" | 19:00 - 23:00 (7pm - 11pm) | 24h |

**C√≥digo UI:** `StepBurstsAndTimes.tsx:13-35`
**C√≥digo Notificaciones:** `NotificationHelper.kt:60-65`
**C√≥digo Scheduler:** `NotificationScheduler.kt:26-27` (usa HOUR_OF_DAY en formato 24h)

**COHERENCIA PERFECTA:**
- ‚úÖ El formato es 24 horas: "20:00" = 8:00 PM
- ‚úÖ Las notificaciones S√ç respetan AM/PM correctamente
- ‚úÖ Cada ventana solo muestra horarios apropiados
- ‚úÖ Los saludos coinciden EXACTAMENTE con las ventanas seleccionadas:
  - **morning** (06:00-11:00) ‚Üí "¬°Buenos d√≠as, {nickname}! üåÖ"
  - **afternoon** (12:00-18:00) ‚Üí "¬°Buenas tardes, {nickname}! ‚òÄÔ∏è"
  - **evening** (19:00-23:00) ‚Üí "¬°Buenas noches, {nickname}! üåô"

---

### 7.6. FRECUENCIA Y CANTIDAD

#### Ejemplo 1: Estudiante Ligero
```javascript
bursts_per_day: 1
active_windows: ["morning"]
weekly_words_target: 10
```
**Resultado:** 1 notificaci√≥n/d√≠a = 7 notificaciones/semana = ~10 palabras/semana

---

#### Ejemplo 2: Estudiante Moderado
```javascript
bursts_per_day: 2
active_windows: ["morning", "evening"]
weekly_words_target: 30
```
**Resultado:** 2 notificaciones/d√≠a = 14 notificaciones/semana = ~30 palabras/semana

---

#### Ejemplo 3: Estudiante Intensivo
```javascript
bursts_per_day: 3
active_windows: ["morning", "afternoon", "evening"]
weekly_words_target: 50
```
**Resultado:** 3 notificaciones/d√≠a = 21 notificaciones/semana = ~50 palabras/semana

---

### 7.7. DEBUGGING EN LOGCAT

Para ver los logs de notificaciones, usa este filtro en Android Studio Logcat:

```
NotificationScheduler|NotificationReceiver|NotificationHelper|NotificationModule
```

**Logs importantes:**
```
NotificationScheduler: Scheduled exact alarm for morning at 8:0 (ID: 283283223)
NotificationScheduler: Next trigger: Sun Oct 05 08:00:00 GMT-06:00 2025

NotificationReceiver: onReceive triggered: com.vocabox.hermes.SHOW_NOTIFICATION
NotificationReceiver: Showing notification for window: morning at 8:0
NotificationReceiver: Rescheduled alarm for tomorrow at 8:0
```

---

### 7.8. CHECKLIST DE VERIFICACI√ìN

Cuando completes el wizard, verifica:

- [ ] ‚úÖ Se guardaron las palabras en SharedPreferences
  - Log: `Saved X words to native storage`
- [ ] ‚úÖ Se programaron las alarmas
  - Log: `Scheduled X notifications`
- [ ] ‚úÖ Las alarmas tienen la hora correcta
  - Log: `Next trigger: [fecha y hora]`
- [ ] ‚úÖ La notificaci√≥n muestra tu nickname
  - T√≠tulo: "¬°Buenos d√≠as, [TU_NICKNAME]! üåÖ"
- [ ] ‚úÖ La palabra es de las categor√≠as seleccionadas
  - Verifica en Supabase que la palabra exista en tus categor√≠as
- [ ] ‚úÖ La notificaci√≥n llega a la hora exacta configurada
  - Compara hora del sistema con `window_times`
- [ ] ‚úÖ Se reprograma autom√°ticamente
  - Log: `Rescheduled alarm for tomorrow`

---

### 7.9. PROBLEMAS COMUNES Y SOLUCIONES

#### Problema 1: No llegan notificaciones
**Causas posibles:**
1. ‚ùå No se concedi√≥ permiso SCHEDULE_EXACT_ALARM (Android 12+)
2. ‚ùå No se desactiv√≥ optimizaci√≥n de bater√≠a
3. ‚ùå No hay palabras en las categor√≠as seleccionadas
4. ‚ùå La hora configurada ya pas√≥ hoy (se programa para ma√±ana)

**Soluci√≥n:**
- Verifica logs de Logcat
- Confirma permisos en Settings ‚Üí Apps ‚Üí VocabloxApp ‚Üí Permisos

---

#### Problema 2: Notificaci√≥n muestra "vocabulary = vocabulario"
**Causa:**
- No hay palabras guardadas en SharedPreferences O
- No hay palabras en las categor√≠as seleccionadas

**Soluci√≥n:**
1. Verifica que existan palabras en Supabase tabla `words`
2. Verifica que tengan las categor√≠as correctas
3. Revisa log: `Saved X words to native storage` (debe ser > 0)

---

#### Problema 3: Notificaci√≥n no se repite al d√≠a siguiente
**Causa:**
- Error en reprogramAlarmForTomorrow()

**Soluci√≥n:**
- Verifica log: `Rescheduled alarm for tomorrow at HH:mm`
- Si no aparece, hay un error en NotificationReceiver.kt

---

### 7.10. COMANDOS ADB PARA TESTING

#### Simular notificaci√≥n inmediata (requiere modificaci√≥n c√≥digo):
```bash
adb shell am broadcast -a com.vocabox.hermes.SHOW_NOTIFICATION
```

#### Ver alarmas programadas:
```bash
adb shell dumpsys alarm | grep vocabox
```

#### Forzar Doze mode (probar que funciona con app cerrada):
```bash
adb shell dumpsys deviceidle force-idle
```

#### Ver SharedPreferences:
```bash
adb shell run-as com.vocabox.hermes cat /data/data/com.vocabox.hermes/shared_prefs/words_storage.xml
```

---

### 7.11. CONCLUSI√ìN

**TU C√ìDIGO YA IMPLEMENTA TODO CORRECTAMENTE:**

‚úÖ Filtra por categor√≠as (NotificationReceiver.kt:39)
‚úÖ Respeta horarios exactos (NotificationScheduler.kt:26-27)
‚úÖ Personaliza con nickname (NotificationHelper.kt:334-339)
‚úÖ Selecciona m√∫ltiples palabras (NotificationReceiver.kt:42-44)
‚úÖ Se reprograma autom√°ticamente (NotificationReceiver.kt:74-115)
‚úÖ Funciona con app cerrada (AlarmManager + BroadcastReceiver)
‚úÖ Ignora Doze mode (setExactAndAllowWhileIdle)

**RECOMENDACI√ìN PARA PRUEBAS R√ÅPIDAS:**
Como las notificaciones se programan para ma√±ana si la hora ya pas√≥, te recomiendo configurar `window_times` con una hora 2-3 minutos en el futuro desde el momento actual para probar inmediatamente.

---

## 8. CAMBIOS RECIENTES DE COHERENCIA
## ====================================

### 8.1. CORRECCI√ìN DE ETIQUETAS SEMANALES (StepWeeklyTarget.tsx)

**Problema anterior:**
- Mostraba "10 palabras/semana" pero realmente eran 14 (2√ó7)
- Mostraba "30 palabras/semana" pero realmente eran 35 (5√ó7)
- Mostraba "40 palabras/semana" pero realmente eran 42 (6√ó7)
- Mostraba "50 palabras/semana" pero realmente eran 56 (8√ó7)

**Soluci√≥n aplicada:**
```javascript
// ANTES
{ value: 10, label: '10 palabras', dailyWords: 2 }

// AHORA
{ value: 10, label: '14 palabras', dailyWords: 2 }  // Honesto: 2√ó7=14 ‚úÖ
```

**Resultado:**
- ‚úÖ Las etiquetas ahora reflejan la cantidad REAL de palabras
- ‚úÖ El preview muestra c√°lculo correcto: `dailyWords * 7`
- ‚úÖ Usuario sabe exactamente cu√°ntas palabras aprender√°

---

### 8.2. HORARIOS ESPEC√çFICOS POR VENTANA (StepBurstsAndTimes.tsx)

**Problema anterior:**
- Todas las ventanas mostraban los mismos horarios (06:00 - 23:00)
- Pod√≠as seleccionar "22:00" para "Ma√±ana" ‚ùå
- Pod√≠as seleccionar "07:00" para "Noche" ‚ùå
- No hab√≠a l√≥gica de AM/PM en la UI

**Soluci√≥n aplicada:**
```javascript
// ANTES (todas las ventanas compart√≠an timeSlots)
const timeSlots = ['06:00', '07:00', ..., '23:00']

// AHORA (cada ventana tiene sus propios horarios)
{
  id: 'morning',
  name: 'Ma√±ana',
  availableSlots: ['06:00', '07:00', '08:00', '09:00', '10:00', '11:00']
},
{
  id: 'afternoon',
  name: 'Tarde',
  availableSlots: ['12:00', '13:00', '14:00', '15:00', '16:00', '17:00', '18:00']
},
{
  id: 'evening',
  name: 'Noche',
  availableSlots: ['19:00', '20:00', '21:00', '22:00', '23:00', '00:00', '01:00']
}
```

**Resultado:**
- ‚úÖ **Ma√±ana** solo muestra 06:00 - 11:00 (6am - 11am)
- ‚úÖ **Tarde** solo muestra 12:00 - 18:00 (12pm - 6pm)
- ‚úÖ **Noche** solo muestra 19:00 - 01:00 (7pm - 1am)
- ‚úÖ Imposible seleccionar horarios incoherentes
- ‚úÖ Incluye medianoche (00:00) y madrugada (01:00) para noche

**Verificaci√≥n t√©cnica:**
```kotlin
// NotificationScheduler.kt usa formato 24h correctamente
set(Calendar.HOUR_OF_DAY, hour)  // ‚úÖ Respeta AM/PM
set(Calendar.MINUTE, minute)

// Ejemplos:
"08:00" ‚Üí hour=8  ‚Üí 8:00 AM ‚úÖ
"20:00" ‚Üí hour=20 ‚Üí 8:00 PM ‚úÖ
"00:00" ‚Üí hour=0  ‚Üí 12:00 AM (medianoche) ‚úÖ
```

---

### 8.3. TABLA DE COHERENCIA FINAL

| Configuraci√≥n Wizard | Notificaci√≥n Programada | ¬øCoherente? |
|---------------------|------------------------|-------------|
| **14 palabras/semana** ‚Üí 2 palabras/d√≠a | `dailyWords = 2` | ‚úÖ |
| **1 sesi√≥n** ‚Üí morning:08:00 | 1 notificaci√≥n a las 8:00 AM | ‚úÖ |
| `words_per_burst = 2` | Selecciona 2 palabras, muestra 1 | ‚úÖ |
| **Ventana: morning** | Solo horarios 06:00-11:00 | ‚úÖ |
| **Ventana: afternoon** | Solo horarios 12:00-18:00 | ‚úÖ |
| **Ventana: evening** | Solo horarios 19:00-01:00 | ‚úÖ |
| Hora seleccionada: **20:00** | Notificaci√≥n a las 8:00 PM | ‚úÖ |
| Hora seleccionada: **00:00** | Notificaci√≥n a las 12:00 AM | ‚úÖ |

---

### 8.4. CASOS DE PRUEBA ACTUALIZADOS

#### CASO B√ÅSICO: 14 palabras/semana, 1 sesi√≥n, ma√±ana 08:00
```javascript
{
  weekly_words_target: 10,  // valor interno
  daily_words: 2,            // calculado
  bursts_per_day: 1,
  active_windows: ["morning"],
  window_times: { morning: "08:00" },
  words_per_burst: 2         // calculado
}
```

**Resultado esperado:**
- ‚úÖ Etiqueta UI: "14 palabras/semana"
- ‚úÖ Preview: "2 palabras/d√≠a"
- ‚úÖ Horarios morning: solo 06:00, 07:00, 08:00, 09:00, 10:00, 11:00
- ‚úÖ Notificaci√≥n: todos los d√≠as a las 8:00 AM
- ‚úÖ Muestra 1 palabra por notificaci√≥n (de 2 seleccionadas)

#### CASO MODERADO: 35 palabras/semana, 2 sesiones, morning:08:00 + evening:20:00
```javascript
{
  weekly_words_target: 30,
  daily_words: 5,
  bursts_per_day: 2,
  active_windows: ["morning", "evening"],
  window_times: { morning: "08:00", evening: "20:00" },
  words_per_burst: 3  // ceil(5/2) = 3
}
```

**Resultado esperado:**
- ‚úÖ Etiqueta UI: "35 palabras/semana"
- ‚úÖ Preview: "5 palabras/d√≠a"
- ‚úÖ Horarios morning: solo 06:00-11:00
- ‚úÖ Horarios evening: solo 19:00-01:00
- ‚úÖ Notificaci√≥n 1: 8:00 AM (morning) con 1 palabra
- ‚úÖ Notificaci√≥n 2: 8:00 PM (evening) con 1 palabra
- ‚úÖ Total real: ~6 palabras/d√≠a √ó 7 = 42 palabras/semana

---

### 8.5. VERIFICACI√ìN DE FORMATO AM/PM

**El sistema usa formato 24 horas PERO respeta correctamente AM/PM:**

| Hora UI | Formato interno | Hora real | Verificaci√≥n |
|---------|----------------|-----------|--------------|
| 06:00 | hour=6, minute=0 | 6:00 AM | ‚úÖ |
| 11:00 | hour=11, minute=0 | 11:00 AM | ‚úÖ |
| 12:00 | hour=12, minute=0 | 12:00 PM (mediod√≠a) | ‚úÖ |
| 18:00 | hour=18, minute=0 | 6:00 PM | ‚úÖ |
| 20:00 | hour=20, minute=0 | 8:00 PM | ‚úÖ |
| 23:00 | hour=23, minute=0 | 11:00 PM | ‚úÖ |
| 00:00 | hour=0, minute=0 | 12:00 AM (medianoche) | ‚úÖ |
| 01:00 | hour=1, minute=0 | 1:00 AM | ‚úÖ |

**C√≥digo responsable:**
```kotlin
// NotificationScheduler.kt:26
set(Calendar.HOUR_OF_DAY, hour)  // Usa sistema 24h de Java Calendar
// NO confundir con HOUR (que ser√≠a 12h y requerir√≠a AM_PM)
```

---

### 8.6. RESUMEN DE MEJORAS

**‚úÖ ANTES:**
- Etiquetas enga√±osas ("10 palabras" pero eran 14)
- Horarios sin restricci√≥n por ventana
- Confusi√≥n sobre AM/PM

**‚úÖ AHORA:**
- Etiquetas honestas ("14 palabras" = 2√ó7)
- Horarios l√≥gicos por ventana (ma√±ana solo AM, noche solo PM)
- Formato 24h claro y correctamente interpretado
- Imposible configurar horarios incoherentes
- Sistema de notificaciones 100% coherente con UI
